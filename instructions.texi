@node Emacs Lisp Byte-Code Instructions
@chapter Emacs Lisp Byte-Code Instructions


@menu
* Instruction-Description Format::
* Argument-Packing Instructions::
* Constants-Vector Retrieval Instructions::
* Exception-Handling Instructions::
* Control-Flow Instructions::
* Function-Call Instructions::
* Stack-Manipulation Instructions::
* Binding Instructions::
* Unused Instructions::
@end menu

@SECTIONA{Instruction-Description Format}

In this chapter we'll document instructions over the course of the
entire history of Emacs. Or at least we aim to.

For the opcode names, we will prefer canonicalized names from the
Emacs C source @code{bytecode.c} (under directory @code{src/}) when
those differ from the names in @code{bytecomp.el} (under directory
@code{lisp/emacs-lisp}). Most of the time they are the same under the
transformation described below.

We use names from @code{bytecode.c} because that is a larger set of
instruction names. Specifically, obsolete instructions names (both
those that can be interpreted even though they are no longer
generated, and some that are no longer interpreted) are defined in
that file, whereas that is not the case in @code{bytecomp.el}.

Names in @code{bytecode.c} must follow C conventions and must be
adjusted to harmonize with other C names used. But this aspect isn't
of use here, so we canonicalize those aspects away.

For example, in @code{bytecode.c} there is an opcode whose name is
@code{Bbuffer_substring}. We will drop the initial @code{B} and
replace all underscores (@verb{|_|}) with dashes
(@verb{|-|}). Therefore we use @code{buffer-substring}.

The corresponding name for that opcode in @code{bytecomp.el} is
@code{byte-buffer-substring}.  For the most part, if you drop the
initial @code{byte-} prefix in the @code{bytecomp.el} name you will
often get the canonic name from @code{bytecode.c}.


However this isn't always true. In particular, consider opcodes 97 and
114; 97 became obsolete in Emacs 24.1 but implemented some kind of
@code{save-current-buffer} instruction. Opcode 97 was then
reused. When the @code{save-current-buffer} instruction was
reintroduced, it got added as opcode 114. In @code{bytecomp.el} only
the name @code{byte-save-current-buffer} appears, while in the C code
the name @code{B_save_current_buffer} is used for opcode 97 and
@code{B_save_current_buffer_1} is used for opcode 114.  And that is
why we go with the @code{bytecode.c} name.  The names we use are
@code{save-current-buffer} and @code{save-current-buffer-1}, even
though the more awkward name, @code{save-current-buffer-1} is what get
generated nowadays.

To shorten and regularize instruction descriptions, each instruction
is described a standard format. We will also require a small
amount of jargon. This jargon are explained below.


@subsection Instruction Jargon
@itemize
@item @code{TOS}
The value of top of the evaluation stack. Many instructions either read or push onto this.
@item @code{S}
This is an array of evaluation stack items. @code{S[0]} is the top of the stack, or
@code{TOS}.
@item @code{top}
A pointer to the the top of the evaluation stack. In C this would be
@code{&TOS}. When we want the stack to increase in size, we add to
top. For example, to makes space to store a new single new value, we
can use @code{top++} and then assign to @code{TOS}.

Note that in changing @code{top}, the value accessed by @code{TOS} or
@code{S} values all change.
@item @math{\phi}
This is used in describing stack effects for branching instructions
where the stack effect is different on one branch versus the
other. This is a function of two arguments. The first argument gives
the stack effect on the non-nil branch and the second argument gives
the stack effect for the nil branch. So @math{\phi(0,-1)} which is
seen in @code{goto-if-not-nil-else-pop} means that if the jump is
taken, the stack effect is 0, otherwise the effect removes or pops an
evaluation-stack entry.
@item instruction-name subscripting (@code{[]})
In many instructions such as @code{constant}, @code{varref}, you will
find an index after the instruction name. What's going on is that
instruction name is one of a number of opcodes in a class encodes an
index into the instruction. We generally call this an
``Argument-encoding'' instruction. In the display of the opcode in
assembly listings and in the opcode table chapter where we list each
opcode, we will include that particular instruction variant in
subscripts.

For example consider @code{constant[0]} versus @code{constant[1]}.
The former has opcode 192 while the latter has opcode 193. In terms of
semantics, the former is the first or zeroth-index entry in a function's constant
vector while the latter is the second or 1-index entry.

@end itemize

@subsection Instruction Description Fields
The description of fields use for describing each instruction is as follows
@table @strong
@item Implements:
A description of what the instruction does.
@item Generated via:
These give some Emacs Lisp constructs that may generate the instruction. Of
course there may be many constructs and there may be limiting
situations within that construct. We'll only give one or a few of the
constructs, and we'll try to indicate a limiting condition where
possible.
@item Operand:
When an instruction has an operand, this descripts the type of the
operand.  Note that the size of the operand (or in some cases the
operand value) will determine the instruction size.
@item Instruction size:
The number of bytes in the instruction. This is 1 to 3 bytes.
@item Stack effect:
This describes how many stack entries are read and popped and how many
entries stack entries are pushed. Although this is logically a tuple,
we'll list this a tuple like @math{(-3, 2)} as a single scalar
@math{-3+2}. In this example, we read/remove three stack entries and
add two.  The reason we give this as @math{-3+2} rather than the tuple
format is so that the overall effect (removing a stack entry) can be
seen by evaluating the expression.
@item Added in:
This is optional. When it is given this gives which version of Emacs
the opcode was added. It may also give when the opcode became obsolete
or was no longer implemented.
@item Example:
Some Emacs Lisp code to show how the instruction is used. For example
the for the @code{goto} instruction we give:

@verbatim
(defun goto-eg(n)
  (while (n) 1300))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [8]
           8
           0
 5  130   goto [0]
           0
           0
 8  135   return

Constants Vector: [n]
@end verbatim

From the above we see that the @code{goto} instruction at
program counter (PC) 5, has decimal opcode 130. The instruction is three bytes
long: a one-byte opcode followed by a two-byte operand.

As we described above under instruction-name subscripting, the
instruction name at PC 0 with opcode 192, @code{constant[0]}, looks
like it is indexing, but it is a just name, where the brackets and
number are part of the name. We use this kind of name because it is
suggestive of how it works. We could have also used instruction names
like @code{constant0} and @code{constant1} for opcodes 192 and 193
instead.

Unless otherwise stated, all code examples were compiled in Emacs 25
with optimization turned off.
@end table

@SECTION{Argument-Packing Instructions}

These instructions from opcode 1 to 47 encode an operand value from 0
to 7 encoded into the first byte.  If the encoded value is 6, the actual
operand value is the byte following the opcode.  If the encoded value
is 7, the actual operand value is the two-byte number following the
opcode, in Little-Endian byte order.

@menu
* stack-ref::
* varref::
* varset::
* varbind::
* call::
* unbind::
@end menu

@FirstSubSecInstruction{stack-ref, 1--7}

Reference a value from the evaluation stack.

@table @strong
@item Implements:
@code{top++; TOS <- S[i+1]} where @code{i} is the value of the
instruction operand.
@item Generated via:
@code{let}, @code{let*} and lambda arguments.
@item Operand:
A stack index
@item Instruction size:
1 byte for @code{stack-ref[0]} .. @code{stack-ref[4]}; 2 bytes for @code{stack-ref[5]}, 8-bit operand;
3 bytes for @code{stack-ref[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Added in:
Added in Emacs 24.1
@item Example:
When lexical binding is in effect,
@verbatim
(defun stack-ref-eg()
  (let ((a 5) (_b 6) (c 7))
    (+ a c)))}
@end verbatim
generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 5
 1  193   constant[1] 6
 2  194   constant[2] 7
 3    2   stack-ref[2]  ;; top++; TOS <- S[3]
 4    1   stack-ref[1]  ;; top++; TOS <- S[2]
 5   92   plus
 6  178   stack-set [3] ;; Set return value, S[2]
          3             ;; before discarding stack entries
 8  136   discard
 9  136   discard
10  135   return

Constants Vector: [5 6 7]
@end verbatim
@end table

@strong{Warning}
Running an instruction with opcode 0 (logically this would be called
@code{stack-ref[0]}), will cause an immediate abort of Emacs in
versions after version 20 and before version 25! The abort of the
opcode was in place before this instruction was added.

Zero is typically an invalid in bytecode and in machine code, since
zero values are commonly found data, e.g. the end of C strings, or
data that has been initialized to value but represents data that
hasn't been written to yet. By having it be an invalid instruction, it
is more likely to catch situations where random sections of memory are
run such as by setting the PC incorrectly.


@SubSecInstruction{varref, 8--15}

Pushes the value of the symbol in the constants vector onto the
evaluation stack.

@kindex varref
@table @strong
@item Implements:
@code{top++; TOS <- (eval constants_vector[i])} where @code{i} is the
value of instruction operand
@item Generated via:
dynamic variable access
@item Operand:
A constants vector index. The constants vector item should be a variable symbol.
@item Instruction size:
1 byte for @code{varref[0]} .. @code{varref[4]}; 2 bytes for @code{varref[5]},
8-bit operand; 3 bytes for @code{varref[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
When dynamic binding is in effect,
@verbatim
(defun varref-eg(n)
  n)
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  135   return

Constants Vector: [n]
@end verbatim
@end table

@SubSecInstruction{varset, 16--23}

Sets a variable listed in the constants vector to the TOS value
of the stack.

@kindex varset
@table @strong
@item Implements:
@code{constants_vector[i] <- TOS; top--} where @code{i} is the value of the
instruction operand.
@item Operand:
A constants vector index. The constants vector item should be a variable symbol.
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
When dynamic binding is in effect,
@verbatim
defun varset(n)
  (setq n 5))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 5
 1  137   dup
 2   16   varset[0] n ;; sets variable n
 3  135   return

Constants Vector: [n 5]
@end verbatim
@end table

@SubSecInstruction{varbind, 24--31}

Binds a variable to a symbol in the constants vector, and adds the
symbol to a special-bindings stack.

@table @strong
@item Implements:
@code{(set_internal(constants_vector[i])} where @code{i} is the value of the
instruction operand.
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
When dynamic binding is in effect,
@verbatim
defun varbind-eg()
  (let ((c 1))
    (1+ c)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 1
 1  137   dup
 2   24   varbind[0] c ;; creates variable c
 3   84   add1
 4   41   unbind[1]    ;; removes variable c
 5  135   return

Constants Vector: [c 1]
@end verbatim
@end table

@SubSecInstruction{call, 32--39}

Calls a function.  The instruction argument specifies the number of
arguments to pass to the function from the stack, excluding the
function itself.

@table @strong
@item Implements:
@code{(set_internal(constants_vector[i])} where @code{i} is the value of the
instruction operand.
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
@verbatim
(defun call-eg()
  (exchange-point-and-mark)
  (next-line 2))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] exchange-point-and-mark
 1   32   call[0]
 2  136   discard
 3  193   constant[1] next-line
 4  194   constant[2] 2
 5   33   call[1]
 6  135   return

Constants Vector: [exchange-point-and-mark next-line 2]
@end verbatim
@end table

@SubSecInstruction{unbind, 40--47}
@kindex unbind

Remove the binding of a variable to symbol and from the special
stack. This is done when the variable is no longer needed.

@table @strong
@item Implements:
@code{(set_internal(constants_vector[i])}
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
When dynamic binding is in effect,
@verbatim
defun varbind-eg()
  (let ((c 1))
    (1+ c)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 1
 1  137   dup
 2   24   varbind[0] c ;; creates variable c
 3   84   add1
 4   41   unbind[1]    ;; removes variable c
 5  135   return

Constants Vector: [c 1]
@end verbatim
@end table


@SECTION{Constants-Vector Retrieval Instructions}

The instructions from opcode 192 to 255 push a value from the
Constants Vector. @xref{Constants Vector}. Opcode 192 pushes the first
entry, opcode 193, the second and so on. If there are more than 64
constants, opcode @code{constant2} (opcode 129) is used instead.

@menu
* constant::
* constant2::
@end menu

@FirstSubSecInstruction{constant, 192--255}
@kindex constant

Pushes a value from the constants vector on the evaluation stack.
There are special instructions to push any one of the first
64 entries in the constants stack.

@table @strong
@item Implements:
@code{top++; TOS <- constants_vector[i]}  where @code{i} is the value of the
instruction operand.
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 25.1
@item Example:
@verbatim
defun n3(n)
  (+ n 10 11 12))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] +
 1    8   varref[0] n
 2  194   constant[2] 10
 3  195   constant[3] 11
 4  196   constant[4] 12
 5   36   call[4]
 6  135   return

Constants Vector: [n + 10 11 12]
@end verbatim
@end table

@SubSecInstruction{constant2, 129}

Pushes a value from the constants vector on the evaluation stack.
Although there are special instructions to push any one of the first
64 entries in the constants stack, this instruction is needed to push
a value beyond one the first 64 entries.

@table @strong
@item Implements:
@code{top++; TOS <- constants_vector[i]} where @code{i} is the value of the
instruction operand.
@item Operand:
a 16-bit index into the constants vector.
@item Instruction size:
3 bytes
@item Stack effect:
@math{-0+1}.
@item Example:
@c @code{(defun n64 (n) (+ n 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64))} generates
@c ((optimize . nil))

@verbatim
(defun n64(n)
 (+ n 0 1 2 3 .. 64))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] +
 1    8   varref[0] n
 2  194   constant[2] 0
 3  195   constant[3] 1
 4  196   constant[4] 2
[...]
63  255   constant[63] 61
64  129   constant2 [64] 62
          64
           0
67  129   constant2 [65] 63
          65
           0
70  129   constant2 [66] 64
          66
           0
73   38   call [66]
          66
75  135   return

Constants Vector: [n + 0 1 2 .. 61 62 63 64]
@end verbatim
@end table

@SECTION{Exception-Handling Instructions}

@menu
* pophandler::
* pushconditioncase::
* pushcatch::
@end menu

@FirstSubSecInstruction{pophandler, 48}

@table @strong
@item Implements:
Removes last condition pushed by @code{pushconditioncase}
@item Generated via:
@code{condition-case}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+0}.
@item Added in:
Emacs 24.4. @xref{Emacs 24}.
@item Example:
@verbatim
(defun pushconditioncase-eg()
  (condition-case nil
    5
    (one-error 6)
    (another-error 7)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (another-error)
 1   49   pushconditioncase [16]
          16
           0
 4  193   constant[1] (one-error)
 5   49   pushconditioncase [12]
          12
           0
 8  194   constant[2] 5
 9   48   pophandler
10   48   pophandler
11  135   return
12   48   pophandler
13  136   discard
14  195   constant[3] 6
15  135   return
16  136   discard
17  196   constant[4] 7
18  135   return

Constants Vector: [(another-error) (one-error) 5 6 7]
@end verbatim

@end table

@SubSecInstruction{pushconditioncase, 49}

@table @strong
@item Implements:
Pops the TOS which is some sort of condition to test on and
registers that. If any of the instructions errors with that condition,
a jump to the operand occurs.
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}.
@item Added in:
Emacs 24.4. @xref{Emacs 24}.
@item Example:
@verbatim
(defun pushconditioncase-eg()
  (condition-case nil
    5
    (one-error 6)
    (another-error 7)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (another-error)
 1   49   pushconditioncase [16]
          16
           0
 4  193   constant[1] (one-error)
 5   49   pushconditioncase [12]
          12
           0
 8  194   constant[2] 5
 9   48   pophandler
10   48   pophandler
11  135   return
12   48   pophandler
13  136   discard
14  195   constant[3] 6
15  135   return
16  136   discard
17  196   constant[4] 7
18  135   return

Constants Vector: [(another-error) (one-error) 5 6 7]
@end verbatim
@end table

@SubSecInstruction{pushcatch, 50}

?


@SECTION{Control-Flow Instructions}

@menu
* goto::
* goto-if-nil::
* goto-if-not-nil::
* goto-if-nil-else-pop::
* goto-if-not-nil-else-pop::
* return::
* switch::
@end menu

@FirstSubSecInstruction{goto, 130}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand
@item Generated via:
@code{while} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-0+0}
@item Example:
@code{(defun goto-eg(n) (while (n) 1300))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [8]
           8
           0
 5  130   goto [0]
           0
           0
 8  135   return

Constants Vector: [n]
@end verbatim

@end table

@SubSecInstruction{goto-if-nil, 131}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is nil. In contrast to
@code{goto-if-nil-else-pop}, the test expression, TOS, is always popped.
@item Generated via:
@code{if} with ``else'' clause and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}
@item Example:
@code{(defun goto-if-nil-eg(n) (if (n) 1310 1311))} generates:
@c ((optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  131   goto-if-nil [9]
           9
           0
 5  193   constant[1] 1310
 6  130   goto [10]
          10
           0
 9  194   constant[2] 1311
10  135   return

Constants Vector: [n 1310 1311]
@end verbatim

@end table

@SubSecInstruction{goto-if-not-nil, 132}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is not nil.  In
contrast to @code{goto-if-not-nil-else-pop}, the test expression, TOS, is
always popped.
@item Generated via:
@code{or} inside an @code{if} with optimization and various
control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}
@item Example:
With bytecode optimization, @code{(defun goto-if-not-nil-eg(n) (if (or (n) (n)) 1320))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  132   goto-if-not-nil [10]
          10
           0
 5  192   constant[0] n
 6   32   call[0]
 7  133   goto-if-nil-else-pop [11]
          11
           0
10  193   constant[1] 1320
11  135   return

Constants Vector: [n 1320]
@end verbatim

Note the change in opcode when bytecode optimization is not performed.
@end table

@SubSecInstruction{goto-if-nil-else-pop, 133}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is nil; otherwise pop
the TOS, the tested condition. This allows the test expression, nil,
to be used again on the branch as the TOS.
@item Generated via:
@code{cond}, @code{if} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{\phi(0,-1)+0}
@item Example:
@code{(defun goto-if-nil-else-pop-eg(n) (cond ((n) 1330)))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [6]
           6
           0
 5  193   constant[1] 1330
 6  135   return

Constants Vector: [n 1330]
@end verbatim

@end table

@SubSecInstruction{goto-if-not-nil-else-pop, 134}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is not nil; otherwise
pop TOS, the tested condition. This allows the tested expression on TOS to be used
again when the jump is taken.
@item Generated via:
@code{cond}, @code{if} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{\phi(0,-1)+0}
@item Example:
@c ((optimize . nil))
@verbatim
(defun goto-if-not-nil-else-pop-eg(n)
  (if (or (n) (n))
    1340))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  134   goto-if-not-nil-else-pop [7]
           7
           0
 5  192   constant[0] n
 6   32   call[0]
 7  133   goto-if-nil-else-pop [11]
          11
           0
10  193   constant[1] 1340
11  135   return

Constants Vector: [n 1340]
@end verbatim

Note the change in opcode when bytecode optimization is performed.
@end table

@SubSecInstruction{return, 135}

@table @strong
@item Implements:
Return from function.  This is the last instruction in a function's
bytecode sequence. The top value on the evaluation stack is the return value.
@item Generated via:
@code{lambda}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+0}
@item Example:
@code{(defun return-eg(n) 1350)} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1350
 1  135   return

Constants Vector: [1350]
@end verbatim

@end table

@SubSecInstruction{switch, 135}

Jumps to entry in a jumptable

@table @strong
@item Implements:
Jumps to entry in a jumptable
@item Generated via:
??
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+0}
@item Added in:
Emacs 26.1
@item Example:
?
@end table

@SECTION{Function-Call Instructions}

These instructions use up one byte, and are followed by the next
instruction directly.  They are equivalent to calling an Emacs Lisp
function with a fixed number of arguments: the arguments are popped
from the stack, and a single return value is pushed back onto the
stack.

@menu
* Lisp Function Instructions::
* List Function Instructions::
* Arithmetic Function Instructions::
* String Function Instructions::
* Emacs Buffer Instructions::
* Emacs Misc Function Instructions::
@end menu

@FirstSubsection{Lisp Function Instructions}

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* symbolp::
* consp::
* stringp::
* listp::
* eq::
* memq::
* not::
* symbol-value::
* symbol-function::
* set::
* fset::
* get::
* equal::
* member::
* assq::
* numberp::
* integerp::
@end menu

@FirstSubSubSecInstruction{symbolp, 57}

Call @code{symbolp}.

@table @strong
@item Implements:
@code{TOS <- (symbolp TOS)}.
@item Generated via:
@code{symbolp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun symbolp-eg(n) (symbolp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   57   symbolp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{consp, 58}

Call @code{consp}.

@table @strong
@item Implements:
@code{TOS <- (consp TOS)}.
@item Generated via:
@code{consp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun consp-eg(n) (consp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   58   consp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{stringp, 59}

Call @code{stringp}.

@table @strong
@item Implements:
@code{TOS <- (stringp TOS)}.
@item Generated via:
unary @code{stringp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun stringp-eg(n) (stringp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   59   stringp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{listp, 60}

Call @code{listp}.

@table @strong
@item Implements:
@code{TOS <- (listp TOS)}.
@item Generated via:
unary @code{listp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun listp-eg(n) (listp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   60   listp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{eq, 61}

Call @code{eq}.

@table @strong
@item Implements:
@code{S[1] <- (eq S[1] TOS); top--}.
@item Generated via:
binary @code{eq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun eq-eg(a b) (eq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   61   eq
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{memq, 62}

@kindex memq

Call @code{memq}.

@table @strong
@item Implements:
@code{S[1] <- (memq S[1] TOS); top--}.
@item Generated via:
binary @code{memq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun memq-eg(a b) (memq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   62   memq
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{not, 63}

@kindex not

Call @code{not}.

@table @strong
@item Implements:
@code{TOS <- (not TOS)}.
@item Generated via:
unary @code{not}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun not-eg(a) (not a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   63   not
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{symbol-value, 74}

Call @code{symbol-value}.

@table @strong
@item Implements:
@code{TOS <- (symbol-value TOS)}.
@item Generated via:
@code{symbol-value}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun symbol-value-eg(a) (symbol-value a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   74   symbol-value
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{symbol-function, 75}

Call @code{symbol-function}.

@table @strong
@item Implements:
@code{TOS <- (symbol-function TOS)}.
@item Generated via:
@code{symbol-function}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun symbol-function-eg(a) (symbol-function a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   75   symbol-function
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{set, 76}

Call @code{set}.

@table @strong
@item Implements:
@code{S[1] <- (set S[1] TOS); top--}.
@item Generated via:
@code{set}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun set-eg(a b) (set a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   76   set
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{fset, 77}

Call @code{fset}.

@table @strong
@item Implements:
@code{S[1] <- (fset S[1] TOS); top--}.
@item Generated via:
binary @code{fset}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun fset-eg(a b) (fset a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   77   fset
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{get, 78}

Call @code{get}.

@table @strong
@item Implements:
@code{S[1] <- (get S[1] TOS); top--}.
@item Generated via:
binary @code{get}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun get-eg(a b) (get a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   78   get
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{equal, 154}

Call @code{equal}.

@table @strong
@item Implements:
@code{S[1] <- (equal S[1] TOS); top--}.
@item Generated via:
binary @code{equal}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect, @code{(defun equal-eg(a b) (equal a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  154   equal
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{member, 157}

Call @code{member}.

@table @strong
@item Implements:
@code{S[1] <- (member S[1] TOS); top--}.
@item Generated via:
@code{member}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun member-eg(a b) (member a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  157   member
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{assq, 158}

Call @code{assq}.

@table @strong
@item Implements:
@code{S[1] <- (assq S[1] TOS); top--}.
@item Generated via:
binary @code{assq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun assq-eg(a b) (assq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  158   assq
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{numberp, 167}

Call @code{numberp}.

@table @strong
@item Implements:
@code{TOS <- (numberp TOS)}.
@item Generated via:
@code{numberp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect, @code{(defun numberp-eg(a) (numberp a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  167   numberp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{integerp, 168}

Call @code{integerp}.

@table @strong
@item Implements:
@code{TOS <- (integerp TOS)}.
@item Generated via:
@code{integerp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect, @code{(defun integerp-eg(a) (integerp a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  168   integerp
 2  135   return
@end verbatim
@end table

@Subsection{List Function Instructions}

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* nth::
* car::
* cdr::
* cons::
* list1::
* list2::
* list3::
* list4::
* listN::
* length::
* aref::
* aset::
* nthcdr::
* elt::
* nreverse::
* setcar::
* setcdr::
* car-safe::
* cdr-safe::
* nconc::
@end menu

@FirstSubSubSecInstruction{nth, 56}

Call @code{nth} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (nth S[1] TOS); top--}.
@item Generated via:
@code{nth}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun nth-eg(l) (nth 560 l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 560
 1    1   stack-ref[1]
 2   56   nth
 3  135   return

Constants Vector: [560]
@end verbatim

@end table

@SubSubSecInstruction{car, 64}

Call @code{car} with one stack argument.


@table @strong
@item Implements:
@code{TOS <- (car TOS)}.
@item Generated via:
@code{car}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun car-eg(l) (car l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   64   car
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{cdr, 65}

Call @code{cdr} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (cdr TOS)}.
@item Generated via:
@code{cdr}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun cdr-eg(l) (cdr l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   65   cdr
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{cons, 66}

Call @code{cons} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (cons S[1] TOS); top--}.
@item Generated via:
@code{cons}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun cons-eg() (cons 'a 'b))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2   66   cons
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table


@SubSubSecInstruction{list1, 67}

Call @code{list} with TOS.

@table @strong
@item Implements:
@code{TOS <- (list TOS)}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun list1-eg() (list 'a))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1   67   list1
 2  135   return

Constants Vector: [a]
@end verbatim

@end table

Call @code{list} with TOS.

@SubSubSecInstruction{list2, 68}

Call @code{list} with two stack items.

@table @strong
@item Implements:
@code{S[1] <- (list S[1] TOS); top--}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun list2-eg() (list 'a 'b))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2   68   list2
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{list3, 69}

Call @code{list} with three stack items.

@table @strong
@item Implements:
@code{S[2] <- (list S[2] S[1] TOS); top -= 2}.
@item Generated via:
@code{list}
@item Instruction size:
1 byte
@item Stack effect:
@math{-3+1}.
@item Example:
@code{(defun list3-eg() (list 'a 'b 'c))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3   69   list3
 4  135   return

Constants Vector: [a b c]
@end verbatim

@end table

@SubSubSecInstruction{list4, 70}

Call @code{list} with four stack items.

@table @strong
@item Implements:
@code{S[3] <- (list S[3] S[2] S[1] TOS); top -= 2}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-4+1}.
@item Example:
@code{(defun list4-eg() (list 'a 'b 'c 'd))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3  195   constant[3] d
 4   70   list4
 5  135   return

Constants Vector: [a b c d]
@end verbatim

@end table

@SubSubSecInstruction{listN, 175}

Call @code{list} on up to 255 items. Note that there are special
instructions for the case where there are 1 to 4 items in the list.

@table @strong
@item Implements:
@code{S[n-1] <- (list S[n-1] S[n-2] ... TOS); top -= (n-1)}.
@item Generated via:
@code{list}.
@item Operand:
8-bit number of items in list
@item Instruction size:
2 bytes
@item Stack effect:
@math{-n+1} where @math{n} is the value of the instruction operand.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun listN-eg() (list 'a 'b 'c 'd 'e))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3  195   constant[3] d
 4  196   constant[4] e
 5  175   listN [5]
           5
 7  135   return

Constants Vector: [a b c d e]
@end verbatim

@end table


@SubSubSecInstruction{length, 71}

Call @code{length} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (length TOS)}.
@item Generated via:
@code{length}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun length-eg() (length '(a b)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (a b)
 1   71   length
 2  135   return

Constants Vector: [(a b)]
@end verbatim

@end table

@SubSubSecInstruction{aref, 72}

Call @code{aref} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (aref S[1] TOS); top--}.
@item Generated via:
@code{aref}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun aref-eg() (aref '[720 721 722] 0))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] [720 721 722]
 1  193   constant[1] 0
 2   72   aref
 3  135   return

Constants Vector: [[720 721 722] 0]
@end verbatim

@end table

@SubSubSecInstruction{aset, 73}

Call @code{aset} with three stack arguments.

@table @strong
@item Implements:
@code{S[2] <- (aset S[2] S[1] TOS); top-=2}.
@item Generated via:
@code{aset}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun aset-eg() (aset array-var 0 730))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0    8   varref[0] array-var
 1  193   constant[1] 0
 2  194   constant[2] 730
 3   73   aset
 4  135   return

Constants Vector: [array-var 0 730]
@end verbatim

@end table


@SubSubSecInstruction{nthcdr, 155}

Call @code{nthcdr} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (nthcdr S[1] TOS); top --}.
@item Generated via:
@code{nthcdr}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun nthcdr-eg() (nthcdr '(1550 1551 1552) 2))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (1550 1551 1552)
 1  193   constant[1] 2
 2  155   nthcdr
 3  135   return

Constants Vector: [(1550 1551 1552) 2]
@end verbatim

@end table


@SubSubSecInstruction{elt, 156}

Call @code{elt} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (elt S[1] TOS); top --}.
@item Generated via:
@code{elt}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun elt-eg() (elt '(1560 1561 1562) 2))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (1560 1561 1562)
 1  193   constant[1] 2
 2  156   elt
 3  135   return

Constants Vector: [(1560 1561 1562) 2]
@end verbatim

@end table

@SubSubSecInstruction{nreverse, 159}

Call @code{nreverse} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (elt TOS)}.
@item Generated via:
@code{nreverse}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun nreverse-eg() (nreverse '(1590 1591)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (1590 1591)
 1  159   nreverse
 2  135   return

Constants Vector: [(1590 1591)]
@end verbatim

@end table

@SubSubSecInstruction{setcar, 160}

Call @code{setcar} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (setcar S[1] TOS); top--}.
@item Generated via:
@code{setcar}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun setcar-eg(l) (setcar l 1600)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  192   constant[0] 1600
 2  160   setcar
 3  135   return

Constants Vector: [1600]
@end verbatim

@end table

@SubSubSecInstruction{setcdr, 161}

Call @code{setcdr} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (setcdr S[1] TOS); top--}.
@item Generated via:
@code{setcdr}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun setcdr-eg(l) (setcdr l 1610)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  192   constant[0] 1610
 2  161   setcdr
 3  135   return

Constants Vector: [1610]
@end verbatim

@end table

@SubSubSecInstruction{car-safe, 162}

Call @code{car-safe} with one argument.

@table @strong
@item Implements:
@code{TOS <- (car-safe TOS)}.
@item Generated via:
@code{car-safe}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun car-safe-eg(l) (car-safe l))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  162   car-safe
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{cdr-safe, 163}

Call @code{cdr-safe} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (cdr-safe TOS)}.
@item Generated via:
@code{cdr-safe}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun cdr-safe-eg(l) (cdr-safe l))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  163   cdr-safe
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{nconc, 164}

Call @code{nconc} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (nconc S[1] TOS); top--}.
@item Generated via:
@code{nconc}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun nconc-eg(a b) (nconc a b))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  164   nconc
 3  135   return
@end verbatim

@end table

@Subsection{Arithmetic Function Instructions}

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* sub1::
* add1::
* eqlsign::
* gtr::
* lss::
* leq::
* geq::
* diff::
* negate::
* plus::
* mult::
* max::
* min::
* quo::
* rem::
@end menu

@FirstSubSubSecInstruction{sub1, 83}

Call @code{1-}.

@table @strong
@item Implements:
@code{TOS <- (1- TOS)}.
@item Generated via:
@code{1-}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun sub1-eg(n) (1- n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   83   sub1
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{add1, 84}

Call @code{1+}.

@table @strong
@item Implements:
@code{TOS <- (1+ TOS)}.
@item Generated via:
unary @code{-}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun add1-eg(n) (1+ n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   84   add1
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{eqlsign, 85}

Call @code{=}.

@table @strong
@item Implements:
@code{S[1] <- (= S[1] TOS); top--}.
@item Generated via:
binary @code{=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun eqlsign-eg(a b) (= a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   85   eqlsign
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{gtr, 86}

Call @code{>}.

@table @strong
@item Implements:
@code{S[1] <- (> S[1] TOS); top--}.
@item Generated via:
@code{>}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun gtr-eg(a b) (> a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   86   gtr
 3  135   return
@end verbatim

@end table

@SubSubSecInstruction{lss, 87}

Call @code{<}.

@table @strong
@item Implements:
@code{S[1] <- (< S[1] TOS); top--}.
@item Generated via:
@code{<}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun lss-eg(a b) (< a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   87   lss
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{leq, 88}

Call @code{<=}.

@table @strong
@item Implements:
@code{S[1] <- (<= S[1] TOS); top--}.
@item Instruction size:
1 byte
@item Generated via:
@code{<=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun leq-eg(a b) (<= a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   88   leq
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{geq, 89}

Call @code{>=}.

@table @strong
@item Implements:
@code{S[1] <- (>= S[1] TOS); top--}.
@item Instruction size:
1 byte
@item Generated via:
@code{>=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun geq-eg(a b) (>= a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   89   geq
 3  135   return
@end verbatim

@end table

@SubSubSecInstruction{diff, 90}

Call binary @code{-}.

@table @strong
@item Implements:
@code{S[1] <- (- S[1] TOS); top--}.
@item Generated via:
binary @code{-}.
@item Instruction size:
1 byte
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun diff-eg(a b) (- a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   90   diff
 3  135   return
@end verbatim

@end table

@SubSubSecInstruction{negate, 91}

Call unary @code{-}.

@table @strong
@item Implements:
@code{TOS <- (- TOS)}.
@item Generated via:
unary @code{-}.
@item Instruction size:
1 byte
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun negate-eg(a) (- a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1   91   negate
 2  135   return

Constants Vector: [a]
@end verbatim

@end table

@SubSubSecInstruction{plus, 92}

Call unary @code{+}.

@table @strong
@item Implements:
@code{S[1] <- (+ S[1] TOS); top--}.
@item Generated via:
@code{+}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun plus-eg(n) (+ n n))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  137   dup
 2   92   plus
 3  135   return

Constants Vector: [n]
@end verbatim

@end table

@SubSubSecInstruction{mult, 95}

Call @code{*}.

@table @strong
@item Implements:
@code{S[1] <- (* S[1] TOS); top--}.
@item Generated via:
@code{*}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When dynamic binding is in effect, @code{(defun mult-eg(n) (* n n))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  137   dup
 2   95   mult
 3  135   return

Constants Vector: [n]
@end verbatim

@end table

@SubSubSecInstruction{max, 93}

Call @code{max}.

@table @strong
@item Implements:
@code{S[1] <- (max S[1] TOS); top--}.
@item Generated via:
@code{max}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun max-eg(a b) (max a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   93   max
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{min, 94}

Call @code{min}.

@table @strong
@item Implements:
@code{TOS <- (min(S[1] TOS)}.
@item Generated via:
binary @code{min}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun min-eg(a b) (min a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   94   min
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{quo, 165}

Call @code{/}.

@table @strong
@item Implements:
@code{S[1] <- (/ S[1] TOS); top--}.
@item Generated via:
@verb{|/|}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun min-quo(a b) (/ a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2  165   quo
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{rem, 166}

Call @verb{|%|}.

@table @strong
@item implements:
@code{S[1] <- (% S[1] TOS); top--}.
@item generated via:
@verb{|%|}
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect, @code{(defun rem-eg(a b) (% a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  166   rem
 3  135   return
@end verbatim

@end table

@Subsection{String Function Instructions}

These instructions correspond to general functions which are not
specific to Emacs; the bytecode interpreter calls the corresponding C
function for them.

@menu
* substring::
* concat2::
* concat3::
* concat4::
* concatN::
* upcase::
* downcase::
* stringeqlsign::
* stringlss::
@end menu

@FirstSubSubSecInstruction{substring, 79}

Call @code{substring} with three stack arguments.

@table @strong
@item Implements:
@code{S[2] <- (substring S[2] S[1] TOS); top-=2}.
@item Generated via:
@code{substring}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun substring-eg() (substring "abc" 0 2))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "abc"
 1  193   constant[1] 0
 2  194   constant[2] 2
 3   79   substring
 4  135   return

Constants Vector: ["abc" 0 2]
@end verbatim

@end table


@SubSubSecInstruction{concat2, 80}

Call @code{concat} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (concat S[1] TOS); top--}.
@item Generated via:
@code{concat}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun concat2-eg() (concat "a" "b"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "a"
 1  193   constant[1] "b"
 2   80   concat2
 3  135   return

Constants Vector: ["a" "b"]
@end verbatim

@end table

@SubSubSecInstruction{concat3, 81}

Call @code{concat} with three stack arguments.

@table @strong
@item Implements:
@code{S[2] <- (concat S[2] S[1] TOS); top-=2}.
@item Generated via:
@code{concat}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun concat3-eg() (concat "a" "b" "c"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "a"
 1  193   constant[1] "b"
 2  194   constant[2] "c"
 3   81   concat3
 4  135   return

Constants Vector: ["a" "b" "c"]
@end verbatim

@end table


@SubSubSecInstruction{concat4, 82}

Call @code{concat} with four stack stack arguments.

@table @strong
@item Implements:
@code{S[3] <- (concat S[3] S[2] S[1] TOS); top -= 2}.
@item Generated via:
@code{concat}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-4+1}.
@item Example:
@code{(defun concat4-eg() (concat "a" "b" "c" "d"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "a"
 1  193   constant[1] "b"
 2  194   constant[2] "c"
 3  195   constant[3] "d"
 4   82   concat4
 5  135   return

Constants Vector: ["a" "b" "c" "d"]
@end verbatim

@end table


@SubSubSecInstruction{concatN, 174}

Call @code{concat} on up to 255 stack arguments.  Note there are
special instructions for the case where there are 2 to 4 items to
concatenate.

@table @strong
@item Implements:
@code{S[n-1] <- (concat S[n-1] S[n-2] ... TOS); top -= (n-1)}.
@item Generated via:
@code{concat}.
@item Operand:
8-bit number of items in concat
@item Instruction size:
2 bytes
@item Stack effect:
@math{-n+1} where @math{n} is the value of the instruction operand.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun concatN-eg() (concat "a" "b" "c" "d" "e"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "a"
 1  193   constant[1] "b"
 2  194   constant[2] "c"
 3  195   constant[3] "d"
 4  196   constant[4] "e"
 5  176   concatN [5]
           5
 7  135   return

Constants Vector: ["a" "b" "c" "d" "e"]
@end verbatim

@end table

@SubSubSecInstruction{upcase, 150}

Call @code{upcase} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (upcase TOS)}.
@item Generated via:
@code{upcase}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun upcase-eg() (upcase "abc"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "abc"
 1  150   upcase
 2  135   return

Constants Vector: ["abc"]
@end verbatim

@end table

@SubSubSecInstruction{downcase, 151}

Call @code{downcase} with one argument.

@table @strong
@item Implements:
@code{TOS <- (downcase TOS)}.
@item Generated via:
@code{downcase}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun downcase-eg(l) (downcase "ABC"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "ABC"
 1  151   downcase
 2  135   return

Constants Vector: ["ABC"]
@end verbatim

@end table

@SubSubSecInstruction{stringeqlsign, 152}

Call @code{string=} with two stack arguments, comparing two strings for equality.

@table @strong
@item Implements:
@code{S[1] <- (string= S[1] TOS); top--}.
@item Generated via:
@code{string=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect,
@verbatim
(defun stringeqlsign-eg(a)
  (string= a "b"))
@end verbatim
generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  192   constant[0] "b"
 2  152   string=
 3  135   return

Constants Vector: ["b"]
@end verbatim

@end table

@SubSubSecInstruction{stringlss, 153}

Call @code{string<} with two stack arguments, comparing two strings.

@table @strong
@item Implements:
@code{S[1] <- (string< S[1] TOS); top--}.
@item Generated via:
@code{string<}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect,
@verbatim
(defun stringlss-eg(a)
  (string< a "b"))
@end verbatim
generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  192   constant[0] "b"
 2  153   string<
 3  135   return

Constants Vector: ["b"]
@end verbatim

@end table

@Subsection{Emacs Buffer Instructions}

@menu
* current-buffer::
* set-buffer::
* save-current-buffer-1::
* buffer-substring::
@end menu

@SubSubSecInstruction{current-buffer, 112}

Call @code{current-buffer}.

@table @strong
@item Implements:
@code{TOS <- (current-buffer)}

@item Generated via:
@code{current-buffer}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun current-buffer-eg() (current-buffer))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  112   current-buffer
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{set-buffer, 113}

Call @code{set-buffer} with TOS.

@table @strong
@item Implements:
@code{TOS <- (set-buffer TOS)}

@item Generated via:
@code{set-buffer}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun set-buffer-eg() (set-buffer "*scratch"))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "*scratch"
 1  113   set-buffer
 2  135   return

Constants Vector: ["*scratch"]
@end verbatim

@end table

@SubSubSecInstruction{save-current-buffer-1, 114}

Call @code{save-current-buffer}.

Replaces older @code{save-current-buffer}. @xref{save-current-buffer}.

@table @strong
@item Implements:
@code{TOS <- (save-current-buffer)}

@item Generated via:
@code{save-current-buffer}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun save-curent-buffer-1-eg() (save-current-buffer (prog 5)))} generates:
@verbatim
PC  Byte  Instruction
 0  114   save-current-buffer
 1  192   constant[0] prog
 2  193   constant[1] 5
 3   33   call[1]
 4   41   unbind[1]
 5  135   return

Constants Vector: [prog 5]
@end verbatim

@end table

@SubSubSecInstruction{buffer-substring, 123}

Call @code{buffer-substring} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (buffer-substring S[1] TOS); top--}.
@item Generated via:
@code{buffer-substring}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun buffer-substring-eg() (buffer-substring 1230 1231))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1230
 1  193   constant[1] 1231
 2  123   buffer-substring
 3  135   return

Constants Vector: [1230 1231]
@end verbatim

@end table

@Subsection{Emacs Misc Function Instructions}

These instructions correspond to Emacs-specific text manipulation
functions. They are generally not inlined by the bytecode interpreter,
but simply call the corresponding C function.

@menu
* point::
* goto-char::
* insert::
* insertN::
* point-max::
* point-min::
* char-after::
* following-char::
* preceding-char::
* current-column::
* eolp::
* eobp::
* bolp::
* bobp::
* forward-char::
* forward-word::
* skip-chars-forward::
* skip-chars-backward::
* forward-line::
* char-syntax::
* delete-region::
* narrow-to-region::
* widen::
* end-of-line::
* save-window-excursion::
* set-marker::
* match-beginning::
* match-end::
@end menu

@FirstSubSubSecInstruction{point, 96}

Call @code{point}.

@table @strong
@item Implements:
@code{TOS <- (point)}

@item Generated via:
@code{point}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 18.31, renamed from @code{dot}. @xref{Emacs 18}.
@item Example:
@code{(defun point-eg() (point))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0   96   point
 1  135   return
@end verbatim

@end table


@SubSubSecInstruction{goto-char, 98}

Call @code{goto-char} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (goto-char TOS)}

@item Generated via:
@code{goto-char}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
With lexical binding in effect, @code{(defun goto-char-eg(n) (goto-char n))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   98   goto-char
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{insert, 99}

Call @code{insert} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (insert TOS)}

@item Generated via:
@code{insert}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
With lexical binding in effect, @code{(defun insert-eg(n) (insert n))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   99   insert
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{insertN, 99}

Call @code{insert} on up to 255 stack arguments.  Note there is a special
instruction when there is only one stack argument.

@table @strong
@item Implements:
@code{S[n-1] <- (insert S[n-1] S[n-2] ... TOS); top -= (n-1)}.

@item Generated via:
@code{insert}
@item Operand:
8-bit number of items in concat
@item Instruction size:
2 bytes
@item Stack effect:
@math{-n+1} where @math{n} is the value of the instruction operand.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun insertN-eg(a b c) (insert a b c))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0    2   stack-ref[2]
 1    2   stack-ref[2]
 2    2   stack-ref[2]
 3  177   insertN [3]
           3
 5  135   return
@end verbatim

@end table

@SubSubSecInstruction{point-max, 100}

Call @code{point-max}.

@table @strong
@item Implements:
@code{TOS <- (point-max)}

@item Generated via:
@code{point-max}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 18.31, renamed from @code{dot-max}. @xref{Emacs 18}.
@item Example:
@code{(defun point-max-eg() (point-max))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  100   point-max
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{point-min, 101}

Call @code{point-min}.

@table @strong
@item Implements:
@code{TOS <- (point-min)}

@item Generated via:
@code{point-min}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 18.31, renamed from @code{dot-min}. @xref{Emacs 18}.
@item Example:
@code{(defun point-min-eg() (point-min))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  101   point-min
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{char-after, 102}

Call @code{char-after} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (char-after TOS)}

@item Generated via:
@code{char-after}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun char-after-eg() (char-after))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] nil
 1  102   char-after
 2  135   return

Constants Vector: [nil]
@end verbatim

@end table

@SubSubSecInstruction{following-char, 103}

Call @code{following-char}.

@table @strong
@item Implements:
@code{TOS <- (following-char TOS)}

@item Generated via:
@code{following-char}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun following-char-eg() (following-char))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  103   following-char
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{preceding-char, 104}

Call @code{preceding-char}.

@table @strong
@item Implements:
@code{TOS <- (preceding-char TOS)}

@item Generated via:
@code{preceding-char}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun preceding-char-eg() (preceding-char))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  104   preceding-char
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{current-column, 105}

Call @code{current-column}.

@table @strong
@item Implements:
@code{TOS <- (current-column)}

@item Generated via:
@code{current-column}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun current-column-eg() (current-column))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  105   current-column
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{eolp, 108}

Call @code{eolp}.

@table @strong
@item Implements:
@code{TOS <- (eolp)}

@item Generated via:
@code{eolp}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun eolp-eg() (eolp))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  108   eolp
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{eobp, 109}

Call @code{eobp}.

@table @strong
@item Implements:
@code{TOS <- (eobp)}

@item Generated via:
@code{eobp}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun eobp-eg() (eobp))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  109   eobp
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{bolp, 110}

Call @code{bolp}.

@table @strong
@item Implements:
@code{TOS <- (bolp)}

@item Generated via:
@code{bolp}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun bolp-eg() (bolp))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  110   bolp
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{bobp, 111}

Call @code{bobp}.

@table @strong
@item Implements:
@code{TOS <- (bobp)}

@item Generated via:
@code{bobp}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun bobp-eg() (bobp))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  111   bobp
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{forward-char, 117}

Call @code{forward-char} with one argument.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{forward-word, 118}

Call @code{forward-word} with one argument.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{skip-chars-forward, 119}

@kindex skip-chars-forward
Call @code{skip-chars-forward} with two stack arguments.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{skip-chars-backward, 120}

Call @code{skip-chars-backward} with two stack arguments.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{forward-line, 121}

Call @code{forward-line} with one argument.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{char-syntax, 122}

Call @code{char-syntax} with one argument.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{delete-region, 124}

Call @code{delete-region} with two stack arguments.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{narrow-to-region, 125}

Call @code{narrow-to-region} with two stack arguments.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{widen, 126}

Call @code{widen}.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{end-of-line, 127}

Call @code{end-of-line} with one argument.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{save-window-excursion, 139}

Added in Emacs 24.1

@SubSubSecInstruction{set-marker, 147}

Call @code{set-marker} with three stack arguments.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{match-beginning, 148}

Call @code{match-beginning} with one argument.

Added in Emacs 19.34. @xref{Emacs 19}.

@SubSubSecInstruction{match-end, 149}

Call @code{match-end} with one argument.

Added in Emacs 19.34. @xref{Emacs 19}.

@SECTION{Stack-Manipulation Instructions}

@menu
* discard::
* discardN::
* dup::
* stack-set::
* stack-set2::
@end menu

@FirstSubSecInstruction{discard, 136}

Discard one value from the stack.

@SubSecInstruction{discardN, 180}

Discards up to 255 arguments from the stack.  Note there is a special
instruction when there is only one argument.

Added in Emacs 24.1

@SubSecInstruction{dup, 137}

Make a copy of the top-of-stack value and push that onto the top of the evaluation stack.

@subsubsection Example
When lexical binding is in effect, @code{(defun en(n) n)} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup  ;; duplicates top of stack: n
 1  135   return
@end verbatim

@SubSecInstruction{stack-set, 180}

Like discard. [What's the difference?]

Added in Emacs 24.1

@SubSecInstruction{stack-set2, 181}

Like discardN. [What's the difference?]
Can handle up to 255 stack arguments.  Note there is a special
instruction when there is only one argument.

Added in Emacs 24.1

@SECTION{Binding Instructions}

These instructions manipulate the special-bindings stack by creating a
new binding when executed.  They need to be balanced with
@code{unbind} instructions.

@menu
* save-excursion::
@end menu

@FirstSubSecInstruction{save-excursion, 138}

Make a binding recording buffer, point, and mark.

@SECTION{Unused Instructions}

These instructions are not generated. In some cases, they were
generated in a older version of Emacs. In some cases the instructions
were planned on being used but never were. In some cases, the
instructions are still handled if they appear (such as from older
bytecode), but in other cases they are no longer accepted by the interperter

@menu
* Rgoto::
* Rgotoifnil::
* Rgotoifnonnil::
* Rgotoifnilelsepop::
* Rgotoifnonnilelsepop::
* save-current-buffer::
* mark::
* scan-buffer::
* read-char::
* set-mark::
* interactive-p::
* condition-case::
* temp-output-buffer-setup::
* temp-output-buffer-show::
* unbind-all::
@end menu

@FirstSubSecInstruction{Rgoto, 170}

Relative jump version of @pxref{goto}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSecInstruction{Rgotoifnil, 171}

Relative jump version of @pxref{goto-if-nil}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSecInstruction{Rgotoifnonnil, 172}

Relative-jump version of @pxref{goto-if-not-nil}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSecInstruction{Rgotoifnilelsepop, 173}

Relative-jump version of @pxref{goto-if-nil-else-pop}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSecInstruction{Rgotoifnonnilelsepop, 174}

Relative-jump version of @pxref{goto-if-not-nil-else-pop}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSecInstruction{save-current-buffer, 97}

Replaced by @code{save-current-buffer-1}. @xref{save-current-buffer-1}.

@FirstSubSecInstruction{mark, 97}

Used in V 17; obsolete in Emacs 18.31. @xref{Emacs 18}.

@FirstSubSecInstruction{scan-buffer, 107}

Obsolete in Emacs 18.31. @xref{Emacs 18}.

@FirstSubSecInstruction{read-char, 114}

@FirstSubSecInstruction{set-mark, 115}

Obsolete in Emacs 18.31. @xref{Emacs 18}.

@FirstSubSecInstruction{interactive-p, 116}

@FirstSubSecInstruction{condition-case, 143}

Replaced by @code{pushconditioncase}. @xref{pushconditioncase}

@table @strong
@item Implements:
?
@item Generated via:
?
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Obsolete since:
Emacs 24.4. @xref{Emacs 24}.
@item Example:
@code{(defun condition-case-eg() (?))} generates:
@c ((lexical . t))
@verbatim
@end verbatim

@end table

@FirstSubSecInstruction{temp-output-buffer-setup, 144}

@table @strong
@item Implements:
?
@item Generated via:
?
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Obsolete since:
Emacs 24.1. @xref{Emacs 24}.
@item Example:
@code{(defun temp-output-buffer-setup-eg() (?))} generates:
@c ((lexical . t))
@verbatim
@end verbatim

@end table

@FirstSubSecInstruction{temp-output-buffer-show, 145}

@table @strong
@item Implements:
?
@item Generated via:
?
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Obsolete in:
Emacs 24.1. @xref{Emacs 24}.
@item Example:
@code{(defun temp-output-buffer-show-eg() (?))} generates:
@c ((lexical . t))
@verbatim
@end verbatim

@end table

@FirstSubSecInstruction{unbind-all, 146}

Introduced in Emacs 19.34 for tail-recursion elimination by jwz, but
never used. @xref{Emacs 19}.
