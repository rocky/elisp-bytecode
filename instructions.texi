@node Emacs Lisp Bytecode Instructions
@chapter Emacs Lisp Bytecode Instructions

Although we document bytecode instructions here, the implementation of
the bytecode interpreter and its instructions appear in
@file{src/bytecode.c}. If there is any question, that should be
consulted as the primary reference.


@menu
* Instruction-Description Format::
* Argument-Packing Instructions::
* Constants-Vector Retrieval Instructions::
* Exception-Handling Instructions::
* Control-Flow Instructions::
* Function-Call Instructions::
* Stack-Manipulation Instructions::
* Obsolete or Unused Instructions::
@end menu

@SECTIONA{Instruction-Description Format}

In this chapter we'll document instructions over the course of the
entire history of Emacs. Or at least we aim to.

For the opcode names, we will prefer canonicalized names from the
Emacs C source @code{bytecode.c} (under directory @code{src/}) when
those differ from the names in @code{bytecomp.el} (under directory
@code{lisp/emacs-lisp}). Most of the time they are the same under the
transformation described below.

We use names from @code{bytecode.c} because that is a larger set of
instruction names. Specifically, obsolete instructions names (both
those that can be interpreted even though they are no longer
generated, and some that are no longer interpreted) are defined in
that file, whereas that is not the case in @code{bytecomp.el}.

Names in @code{bytecode.c} must follow C conventions and must be
adjusted to harmonize with other C names used. But this aspect isn't
of use here, so we canonicalize those aspects away.

For example, in @code{bytecode.c} there is an opcode whose name is
@code{Bbuffer_substring}. We will drop the initial @code{B} and
replace all underscores (@verb{|_|}) with dashes
(@verb{|-|}). Therefore we use @code{buffer-substring}.

The corresponding name for that opcode in @code{bytecomp.el} is
@code{byte-buffer-substring}.  For the most part, if you drop the
initial @code{byte-} prefix in the @code{bytecomp.el} name you will
often get the canonic name from @code{bytecode.c}.

However this isn't always true. The instruction that the Emacs Lisp
@code{save-current-buffer} function generates nowadays has opcode
value 114.  In the C code, this value is listed as
@code{B_save_current_buffer_1}; @code{bytecomp.el} uses the name
@code{byte-save-current-buffer}.  We report the instruction name for
opcode 114 as @code{save-current-buffer-1}.

To shorten and regularize instruction descriptions, each instruction
is described a standard format. We will also require a small
amount of jargon. This jargon are explained below.


@subsection Instruction Jargon
@itemize
@item @code{OPERAND}
The value of operand of the instruction. Many times this is done by
taking the value of the opcode and subtracting from it the value of
the first opcode in the series of opcodes it is part of.  For example,
the @code{call} opcodes span opcode values 32 to 39. The
@code{OPERAND} value for opcode 32 then is @math{0 = 32-32}; for
opcode 33, the value is @math{1 = 33-32}.
@item @code{TOS}
The value of top of the evaluation stack. Many instructions either read or push onto this.
@item @code{S}
This is an array of evaluation stack items. @code{S[0]} is the top of
the stack, or @code{TOS}.

Note that indexing starts from the top of the stack and increases as
we move down the stack.
@item @code{top}
A pointer to the the top of the evaluation stack. In C this would be
@code{&TOS}. When we want the stack to increase in size, we add to
top. For example, to makes space to store a new single new value, we
can use @code{top++} and then assign to @code{TOS}.

Note that in changing @code{top}, the value accessed by @code{TOS} or
@code{S} values all change.
@item @math{\phi}
This is used in describing stack effects for branching instructions
where the stack effect is different on one branch versus the
other. This is a function of two arguments. The first argument gives
the stack effect on the non-nil branch and the second argument gives
the stack effect for the nil branch. So @math{\phi(0,-1)} which is
seen in @code{goto-if-not-nil-else-pop} means that if the jump is
taken, the stack effect is 0, otherwise the effect removes or pops an
evaluation-stack entry.

@item instruction-name subscripting (@code{[]})
In many instructions such as @code{constant}, @code{varref}, you will
find an index after the instruction name. What's going on is that
instruction name is one of a number of opcodes in a class encodes an
index into the instruction. We generally call this an
``Argument-encoding'' instruction. In the display of the opcode in
assembly listings and in the opcode table chapter where we list each
opcode, we will include that particular instruction variant in
subscripts.

For example consider @code{constant[0]} versus @code{constant[1]}.
The former has opcode 192 while the latter has opcode 193. In terms of
semantics, the former is the first or zeroth-index entry in a function's constant
vector while the latter is the second or 1-index entry.

@item eval stack types
Just as in Emacs Lisp, many functions expect their arguments to be of
a certain type, so it is true in Bytecode. Although the information
here mirrors what is described in the Emacs Lisp Reference Manual
(@pxref{Lisp Data Types, , Lisp Data Types, elisp, The GNU Emacs Lisp
Reference Manual}), for convenience we include that here as well.
@end itemize

@subsection Instruction Description Fields
The description of fields use for describing each instruction is as follows
@table @strong
@item Implements:
A description of what the instruction does.
@item Generated via:
These give some Emacs Lisp constructs that may generate the instruction. Of
course there may be many constructs and there may be limiting
situations within that construct. We'll only give one or a few of the
constructs, and we'll try to indicate a limiting condition where
possible.
@item Operand:
When an instruction has an operand, this describes the type of the
operand.  Note that the size of the operand (or in some cases the
operand value) will determine the instruction size.
@item Instruction size:
The number of bytes in the instruction. This is 1 to 3 bytes.
@item Stack effect:
This describes how many stack entries are read and popped and how many
entries stack entries are pushed. Although this is logically a tuple,
we'll list this a tuple like @math{(-3, 2)} as a single scalar
@math{-3+2}. In this example, we read/remove three stack entries and
add two.  The reason we give this as @math{-3+2} rather than the tuple
format is so that the overall effect (removing a stack entry) can be
seen by evaluating the expression.
@item Added in:
This is optional. When it is given this gives which version of Emacs
the opcode was added. It may also give when the opcode became obsolete
or was no longer implemented.
@item Example:
Some Emacs Lisp code to show how the instruction is used. For example
the for the @code{goto} instruction we give:

@verbatim
(defun goto-eg(n)
  (while (n) 1300))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [8]
           8
           0
 5  130   goto [0]
           0
           0
 8  135   return

Constants Vector: [n]
@end verbatim

From the above we see that the @code{goto} instruction at
program counter (PC) 5, has decimal opcode 130. The instruction is three bytes
long: a one-byte opcode followed by a two-byte operand.

The instruction name at PC 0 with opcode 192, @code{constant[0]},
looks like it is indexing, but it is a just name, where the brackets
and number are part of the name. We use this kind of name because it
is suggestive of how it works: it indexes the first element into the
constants vector and pushes that value onto the evaluation
stack. @code{constant[1]} with opcode 193 pushes the second element of
the constants vector onto the stack. We could have also used
instruction names like @code{constant0} and @code{constant1} for
opcodes 192 and 193 instead.

Unless otherwise stated, all code examples were compiled in Emacs 25
with optimization turned off.
@end table

@SECTION{Argument-Packing Instructions}

These instructions from opcode 1 to 47 encode an operand value from 0
to 7 encoded into the first byte.  If the encoded value is 6, the actual
operand value is the byte following the opcode.  If the encoded value
is 7, the actual operand value is the two-byte number following the
opcode, in Little-Endian byte order.

@menu
* stack-ref::
* varref::
* varset::
* varbind::
* call::
* unbind::
@end menu

@FirstSubSecInstruction{stack-ref, 1--7}

Reference a value from the evaluation stack.

@table @strong
@item Implements:
@code{top++; TOS <- S[OPERAND+1]}
@item Generated via:
@code{let}, @code{let*} and lambda arguments.
@item Operand:
A stack index
@item Instruction size:
1 byte for @code{stack-ref[0]} .. @code{stack-ref[4]}; 2 bytes for @code{stack-ref[5]}, 8-bit operand;
3 bytes for @code{stack-ref[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Type Information:

@strong{after:} @code{TOS: Object}

@item Added in:
Emacs 24.1. @xref{Emacs 24}.
@item Example:
When lexical binding and optimization are in effect,
@verbatim
(defun stack-ref-eg()
  (let ((a 5) (_b 6) (c 7))
    (+ a c)))}
@end verbatim
generates:
@c ((lexical . t) (optimize . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 5 ;; top++; TOS <- 5
 1  193   constant[1] 6 ;; top++; TOS <- 6
 2  194   constant[2] 7 ;; top++; TOS <- 7
 3    2   stack-ref[2]  ;; top++; TOS <- S[3] (5)
 4    1   stack-ref[1]  ;; top++; TOS <- S[2] (7)
 5   92   plus
 6  135   return

Constants Vector: [5 6 7]
@end verbatim

@end table

@strong{Warning}
Running an instruction with opcode 0 (logically this would be called
@code{stack-ref[0]}), will cause an immediate abort of Emacs in
versions after version 20 and before version 25! The abort of the
opcode was in place before this instruction was added.

Zero is typically an invalid in bytecode and in machine code, since
zero values are commonly found data, e.g. the end of C strings, or
data that has been initialized to value but represents data that
hasn't been written to yet. By having it be an invalid instruction, it
is more likely to catch situations where random sections of memory are
run such as by setting the PC incorrectly.


@SubSecInstruction{varref, 8--15}

Pushes the value of the symbol in the constants vector onto the
evaluation stack.

@kindex varref
@table @strong
@item Implements:
@code{top++; TOS <- (eval constants[OPERAND])}
@item Generated via:
dynamic variable access
@item Operand:
A constants vector index. The constants vector item should be a variable symbol.
@item Instruction size:
1 byte for @code{varref[0]} .. @code{varref[4]}; 2 bytes for @code{varref[5]},
8-bit operand; 3 bytes for @code{varref[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Type Information:

@strong{after:} @code{TOS: Object}

@item Example:
When dynamic binding is in effect,
@verbatim
(defun varref-eg(n)
  n)
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  135   return

Constants Vector: [n]
@end verbatim
@end table

@SubSecInstruction{varset, 16--23}

Sets a variable listed in the constants vector to the TOS value
of the stack.

@kindex varset
@table @strong
@item Implements:
@code{constants[OPERAND] <- TOS; top--}
@item Operand:
A constants vector index. The constants vector item should be a variable symbol.
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-1+0}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@item Example:
When dynamic binding is in effect,
@verbatim
defun varset-eg(n)
  (setq n 5))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 5
 1  137   dup
 2   16   varset[0] n ;; sets variable n
 3  135   return

Constants Vector: [n 5]
@end verbatim
@end table

@SubSecInstruction{varbind, 24--31}

Binds a variable to a symbol in the constants vector, and adds the
symbol to a special-bindings stack.

@table @strong
@item Implements:
@code{*constants[OPERAND]<-TOS; top--}
@item Instruction size:
1 byte for @code{varbind[0]} .. @code{varbind[4]}; 2 bytes for @code{varbind[5]},
8-bit operand; 3 bytes for @code{varbind[6]}, 16-bit operand.
@item Stack effect:
@math{-1+0}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@item Example:
When dynamic binding is in effect,
@verbatim
defun varbind-eg()
  (let ((c 1))
    (1+ c)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 1
 1  137   dup
 2   24   varbind[0] c ;; creates variable c
 3   84   add1
 4   41   unbind[1]    ;; removes variable c
 5  135   return

Constants Vector: [c 1]
@end verbatim
@end table

@SubSecInstruction{call, 32--39}

Calls a function.  The instruction argument specifies the number of
arguments to pass to the function from the stack, excluding the
function itself.

@table @strong
@item Implements:
@verbatim
arg[0..OPERAND-1] = S[OPERAND-1..0]
fn <- S[OPERAND];
top -= OPERAND;
TOS <- fn(*arg) # replace fn by the fn's return value
@end verbatim

Before the call, the top of the stack has the final call parameter, if
there is one. If there are no parameters, the top of the stack has the
function to be called. The function to be called is always the least
recent evaluation stack entry followed the function parameters
in the order they were given.

For example, for @code{gcd(1, 2)} the value of @code{OPERAND} is 2.
The evaluation stack before the function call will be:
@verbatim
+------------+
| S[0] : 2   |
+------------+
| S[1] : 1   |
+------------+
| S[2] : gcd |
+------------+
@end verbatim

After the call completes, the evaluation stack will be:
@verbatim
+-------------------------+
| S[0] : gcd-return-value |
+-------------------------+
@end verbatim

@item Instruction size:
1 byte for @code{call[0]} .. @code{call[4]}; 2 bytes for @code{call[5]},
8-bit operand; 3 bytes for @code{call[6]}, 16-bit operand.
@item Stack effect:
@math{-(@code{OPERAND}+1)+1}.
@item Example:
@verbatim
(defun call-eg()
  (exchange-point-and-mark)
  (next-line 2))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] exchange-point-and-mark
 1   32   call[0]
 2  136   discard
 3  193   constant[1] next-line
 4  194   constant[2] 2
 5   33   call[1]
 6  135   return

Constants Vector: [exchange-point-and-mark next-line 2]
@end verbatim
@end table

@SubSecInstruction{unbind, 40--47}
@kindex unbind

Remove the binding of a variable to symbol and from the special
stack. This is done when the variable is no longer needed.

@table @strong
@item Implements:
undo's a @code{let}, @code{unwind-protect}s, and @code{save-excursion}s
@item Generated via:
@code{let} in dynamic binding. Balancing the end of @code{save-excursion}.
@item Instruction size:
1 byte for @code{unbind[0]} .. @code{unbind[4]}; 2 bytes for @code{unbind[5]},
8-bit operand; 3 bytes for @code{unbind[6]}, 16-bit operand.
@item Stack effect:
@math{-0+0}.
@item Example:
When dynamic binding is in effect,
@verbatim
defun varbind-eg()
  (let ((c 1))
    (1+ c)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 1
 1  137   dup
 2   24   varbind[0] c ;; creates variable c
 3   84   add1
 4   41   unbind[1]    ;; removes variable c
 5  135   return

Constants Vector: [c 1]
@end verbatim
@end table


@SECTION{Constants-Vector Retrieval Instructions}

The instructions from opcode 192 to 255 push a value from the
Constants Vector. @xref{Constants Vector}. Opcode 192 pushes the first
entry, opcode 193, the second and so on. If there are more than 64
constants, opcode @code{constant2} (opcode 129) is used instead.

@menu
* constant::
* constant2::
@end menu

@FirstSubSecInstruction{constant, 192--255}
@kindex constant

Pushes a value from the constants vector on the evaluation stack.
There are special instructions to push any one of the first
64 entries in the constants stack.

@table @strong
@item Implements:
@code{top++; TOS <- constants[OPERAND]}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.

@item Type Information:

@strong{after:} @code{TOS: Object}

@item Example:
@verbatim
defun n3(n)
  (+ n 10 11 12))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] +
 1    8   varref[0] n
 2  194   constant[2] 10
 3  195   constant[3] 11
 4  196   constant[4] 12
 5   36   call[4]
 6  135   return

Constants Vector: [n + 10 11 12]
@end verbatim
@end table

@SubSecInstruction{constant2, 129}

Pushes a value from the constants vector on the evaluation stack.
Although there are special instructions to push any one of the first
64 entries in the constants stack, this instruction is needed to push
a value beyond one the first 64 entries.

@table @strong
@item Implements:
@code{top++; TOS <- constants[OPERAND]}
@item Operand:
a 16-bit index into the constants vector.
@item Instruction size:
3 bytes
@item Stack effect:
@math{-0+1}.
@item Example:
@c @code{(defun n64 (n) (+ n 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64))} generates
@c ((optimize . nil))

@verbatim
(defun n64(n)
 (+ n 0 1 2 3 .. 64))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] +
 1    8   varref[0] n
 2  194   constant[2] 0
 3  195   constant[3] 1
 4  196   constant[4] 2
[...]
63  255   constant[63] 61
64  129   constant2 [64] 62
          64
           0
67  129   constant2 [65] 63
          65
           0
70  129   constant2 [66] 64
          66
           0
73   38   call [66]
          66
75  135   return

Constants Vector: [n + 0 1 2 .. 61 62 63 64]
@end verbatim
@end table

@SECTION{Exception-Handling Instructions}

@menu
* pophandler::
* pushconditioncase::
* pushcatch::
@end menu

@FirstSubSecInstruction{pophandler, 48}

@table @strong
@item Implements:
Removes last condition pushed by @code{pushconditioncase}
@item Generated via:
@code{condition-case}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+0}.
@item Added in:
Emacs 24.4. @xref{Emacs 24}.
@item Example:
@verbatim
(defun pushconditioncase-eg()
  (condition-case nil
    5
    (one-error 6)
    (another-error 7)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (another-error)
 1   49   pushconditioncase [16]
          16
           0
 4  193   constant[1] (one-error)
 5   49   pushconditioncase [12]
          12
           0
 8  194   constant[2] 5
 9   48   pophandler
10   48   pophandler
11  135   return
12   48   pophandler
13  136   discard
14  195   constant[3] 6
15  135   return
16  136   discard
17  196   constant[4] 7
18  135   return

Constants Vector: [(another-error) (one-error) 5 6 7]
@end verbatim

@end table

@SubSecInstruction{pushconditioncase, 49}

@table @strong
@item Implements:
Pops the TOS which is some sort of condition to test on and
registers that. If any of the instructions errors with that condition,
a jump to the operand occurs.
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}.
@item Added in:
Emacs 24.4. @xref{Emacs 24}.
@item Example:
@verbatim
(defun pushconditioncase-eg()
  (condition-case nil
    5
    (one-error 6)
    (another-error 7)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (another-error)
 1   49   pushconditioncase [16]
          16
           0
 4  193   constant[1] (one-error)
 5   49   pushconditioncase [12]
          12
           0
 8  194   constant[2] 5
 9   48   pophandler
10   48   pophandler
11  135   return
12   48   pophandler
13  136   discard
14  195   constant[3] 6
15  135   return
16  136   discard
17  196   constant[4] 7
18  135   return

Constants Vector: [(another-error) (one-error) 5 6 7]
@end verbatim
@end table

@SubSecInstruction{pushcatch, 50}

?


@SECTION{Control-Flow Instructions}

@menu
* goto::
* goto-if-nil::
* goto-if-not-nil::
* goto-if-nil-else-pop::
* goto-if-not-nil-else-pop::
* return::
* switch::
@end menu

@FirstSubSecInstruction{goto, 130}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand
@item Generated via:
@code{while} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-0+0}
@item Example:
@code{(defun goto-eg(n) (while (n) 1300))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [8]
           8
           0
 5  130   goto [0]
           0
           0
 8  135   return

Constants Vector: [n]
@end verbatim

@end table

@SubSecInstruction{goto-if-nil, 131}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is nil. In contrast to
@code{goto-if-nil-else-pop}, the test expression, TOS, is always popped.
@item Generated via:
@code{if} with ``else'' clause and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}
@item Example:
@code{(defun goto-if-nil-eg(n) (if (n) 1310 1311))} generates:
@c ((optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  131   goto-if-nil [9]
           9
           0
 5  193   constant[1] 1310
 6  130   goto [10]
          10
           0
 9  194   constant[2] 1311
10  135   return

Constants Vector: [n 1310 1311]
@end verbatim

@end table

@SubSecInstruction{goto-if-not-nil, 132}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is not nil.  In
contrast to @code{goto-if-not-nil-else-pop}, the test expression, TOS, is
always popped.
@item Generated via:
@code{or} inside an @code{if} with optimization and various
control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}
@item Example:
With bytecode optimization, @code{(defun goto-if-not-nil-eg(n) (if (or (n) (n)) 1320))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  132   goto-if-not-nil [10]
          10
           0
 5  192   constant[0] n
 6   32   call[0]
 7  133   goto-if-nil-else-pop [11]
          11
           0
10  193   constant[1] 1320
11  135   return

Constants Vector: [n 1320]
@end verbatim

Note the change in opcode when bytecode optimization is not performed.
@end table

@SubSecInstruction{goto-if-nil-else-pop, 133}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is nil; otherwise pop
the TOS, the tested condition. This allows the test expression, nil,
to be used again on the branch as the TOS.
@item Generated via:
@code{cond}, @code{if} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{\phi(0,-1)+0}
@item Example:
@code{(defun goto-if-nil-else-pop-eg(n) (cond ((n) 1330)))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [6]
           6
           0
 5  193   constant[1] 1330
 6  135   return

Constants Vector: [n 1330]
@end verbatim

@end table

@SubSecInstruction{goto-if-not-nil-else-pop, 134}

@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is not nil; otherwise
pop TOS, the tested condition. This allows the tested expression on TOS to be used
again when the jump is taken.
@item Generated via:
@code{cond}, @code{if} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{\phi(0,-1)+0}
@item Example:
@c ((optimize . nil))
@verbatim
(defun goto-if-not-nil-else-pop-eg(n)
  (if (or (n) (n))
    1340))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  134   goto-if-not-nil-else-pop [7]
           7
           0
 5  192   constant[0] n
 6   32   call[0]
 7  133   goto-if-nil-else-pop [11]
          11
           0
10  193   constant[1] 1340
11  135   return

Constants Vector: [n 1340]
@end verbatim

Note the change in opcode when bytecode optimization is performed.
@end table

@SubSecInstruction{return, 135}

@table @strong
@item Implements:
Return from function.  This is the last instruction in a function's
bytecode sequence. The top value on the evaluation stack is the return value.
@item Generated via:
@code{lambda}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+0}
@item Example:
@code{(defun return-eg(n) 1350)} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1350
 1  135   return

Constants Vector: [1350]
@end verbatim

@end table

@SubSecInstruction{switch, 183}

Jumps to entry in a jump table.

@table @strong
@item Implements:
switch-like jump table. Top of stack is a variable reference. Below that
is a hash table mapping compared values to instructions offsets.
@item Generated via:
@code{cond} with several clauses that use the same test function and variable.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+0}
@item Added in:
Emacs 26.1
@item Example:
@verbatim
(defun switch-eg(n)
   (cond ((equal n 1) 1)
          ((equal n 2) 2)
          ((equal n 3) 3)))

@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  193   constant[1] #s(hash-table size 3 test equal rehash-size 1.5 rehash-threshold 0.8125 purecopy t data (1 6 2 8 3 10))
 2  183   switch
 3  130   goto [12]
          12
           0
 6  194   constant[2] 1
 7  135   return
 8  195   constant[3] 2
 9  135   return
10  196   constant[4] 3
11  135   return
12  197   constant[5] nil
13  135   return

Constants Vector: [n #s(hash-table size 2 test equal rehash-size 1.5 rehash-threshold 0.8125 purecopy t data (1 6 2 8)) 1 3 nil]
@end verbatim

@end table

@SECTION{Function-Call Instructions}

These instructions use up one byte, and are followed by the next
instruction directly.  They are equivalent to calling an Emacs Lisp
function with a fixed number of arguments: the arguments are popped
from the stack, and a single return value is pushed back onto the
stack.

@menu
* Lisp Function Instructions::
* List Function Instructions::
* Arithmetic Function Instructions::
* String Function Instructions::
* Emacs Buffer Instructions::
* Emacs Position Instructions::
* Emacs Text Instructions::
* Emacs Misc Function Instructions::
@end menu

@FirstSubsection{Lisp Function Instructions}

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* symbolp::
* consp::
* stringp::
* listp::
* eq::
* memq::
* not::
* symbol-value::
* symbol-function::
* set::
* fset::
* get::
* equal::
* member::
* assq::
* numberp::
* integerp::
@end menu

@FirstSubSubSecInstruction{symbolp, 57}

Call @code{symbolp}. For a description of this Emacs Lisp function, @xref{Symbols, , Symbols, elisp, The GNU Emacs Lisp Reference Manual}, .

@table @strong
@item Implements:
@code{TOS <- (symbolp TOS)}.
@item Generated via:
@code{symbolp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@strong{after:} @code{TOS: Bool}

@item Example:
When lexical binding is in effect, @code{(defun symbolp-eg(n) (symbolp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   57   symbolp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{consp, 58}

Call @code{consp}. For a description of this Emacs Lisp function,
@xref{List-related Predicates, , Predicates on Lists, The GNU Emacs
Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (consp TOS)}.
@item Generated via:
@code{consp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@strong{after:} @code{TOS: Bool}

@item Example:
When lexical binding is in effect, @code{(defun consp-eg(n) (consp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   58   consp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{stringp, 59}

Call @code{stringp}. For a description of this Emacs Lisp string predicate,
@xref{Predicates for Strings, , Predicates for Strings, elisp, The GNU
Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (stringp TOS)}.
@item Generated via:
unary @code{stringp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@strong{after:} @code{TOS: Bool}

@item Example:
When lexical binding is in effect, @code{(defun stringp-eg(n) (stringp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   59   stringp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{listp, 60}

Call @code{listp}.  For a description of this Emacs Lisp list
predicate, @xref{List-related Predicates, , Predicates on Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (listp TOS)}.
@item Generated via:
unary @code{listp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@strong{after:} @code{TOS: Bool}

@item Example:
When lexical binding is in effect, @code{(defun listp-eg(n) (listp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   60   listp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{eq, 61}

Call @code{eq}.  For a description of this Emacs Lisp equality
predicate, @xref{Equality Predicates, ,Equality Predicates, elisp, The
GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (eq S[1] TOS); top--}.
@item Generated via:
binary @code{eq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun eq-eg(a b) (eq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   61   eq
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{memq, 62}

@kindex memq

Call @code{memq}. For a description of this Emacs Lisp list function,
@xref{Sets And Lists, ,Using Lists as Sets, elisp, The GNU Emacs Lisp
Reference Manual}.


@table @strong
@item Implements:
@code{S[1] <- (memq S[1] TOS); top--}.
@item Generated via:
binary @code{memq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Type Information:

@strong{before:} @code{TOS: List; S[1]: Object}

@strong{after:} @code{TOS: Object}

@item Example:
When lexical binding is in effect, @code{(defun memq-eg(a b) (memq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   62   memq
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{not, 63}

@kindex not

Call @code{not}. For a description of this Emacs Lisp combining
condition, @xref{Combining Conditions, ,Constructs for Combining
Conditions, elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (not TOS)}.
@item Generated via:
unary @code{not}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@strong{after:} @code{TOS: Bool}


@item Example:
When lexical binding is in effect, @code{(defun not-eg(a) (not a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   63   not
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{symbol-value, 74}

Call @code{symbol-value}. For a description of this Emacs Lisp
function, @xref{Accessing Variables, ,Accessing Variable Values,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (symbol-value TOS)}.
@item Generated via:
@code{symbol-value}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun symbol-value-eg(a) (symbol-value a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   74   symbol-value
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{symbol-function, 75}

Call @code{symbol-function}. For a description of this Emacs Lisp
function, @xref{Function Cells, ,Accessing Function Cell Contents,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (symbol-function TOS)}.
@item Generated via:
@code{symbol-function}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun symbol-function-eg(a) (symbol-function a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   75   symbol-function
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{set, 76}

Call @code{set}. For a description of this Emacs Lisp function,
@xref{Setting Variables, ,Setting Variable Values, elisp, The GNU
Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (set S[1] TOS); top--}.
@item Generated via:
@code{set}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun set-eg(a b) (set a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   76   set
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{fset, 77}

Call @code{fset}. For a description of this
Emacs Lisp function, @xref{Function Cells, ,Accessing Function Cell Contents,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (fset S[1] TOS); top--}.
@item Generated via:
binary @code{fset}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun fset-eg(a b) (fset a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   77   fset
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{get, 78}

Call @code{get}. For a description of this Emacs Lisp function,
@xref{Symbol Plists, ,Accessing Symbol Properties, elisp, The GNU
Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (get S[1] TOS); top--}.
@item Generated via:
binary @code{get}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun get-eg(a b) (get a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   78   get
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{equal, 154}

Call @code{equal}. For a description of this
Emacs Lisp function, @xref{Equality Predicates, ,Equality Predicates,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (equal S[1] TOS); top--}.
@item Generated via:
binary @code{equal}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect, @code{(defun equal-eg(a b) (equal a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  154   equal
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{member, 157}

Call @code{member}. For a description of this
Emacs Lisp function, @xref{Sets And Lists, ,Using Lists as Sets,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (member S[1] TOS); top--}.
@item Generated via:
@code{member}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun member-eg(a b) (member a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  157   member
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{assq, 158}

Call @code{assq}. For a description of this
Emacs Lisp function, @xref{Association Lists, ,Association Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (assq S[1] TOS); top--}.
@item Generated via:
binary @code{assq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun assq-eg(a b) (assq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  158   assq
 3  135   return
@end verbatim
@end table

@SubSubSecInstruction{numberp, 167}

Call @code{numberp}. For a description of this
Emacs Lisp function, @xref{Predicates on Numbers, ,Type Predicates for Numbers,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (numberp TOS)}.
@item Generated via:
@code{numberp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@strong{after:} @code{TOS: Bool}

@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect, @code{(defun numberp-eg(a) (numberp a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  167   numberp
 2  135   return
@end verbatim
@end table

@SubSubSecInstruction{integerp, 168}

Call @code{integerp}. For a description of this Emacs Lisp function,
@xref{Predicates on Numbers, ,Type Predicates for Numbers, elisp, The
GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (integerp TOS)}.
@item Generated via:
@code{integerp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@strong{after:} @code{TOS: Bool}

@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect, @code{(defun integerp-eg(a) (integerp a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  168   integerp
 2  135   return
@end verbatim
@end table

@Subsection{List Function Instructions}

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* nth::
* car::
* cdr::
* cons::
* list1::
* list2::
* list3::
* list4::
* listN::
* length::
* aref::
* aset::
* nthcdr::
* elt::
* nreverse::
* setcar::
* setcdr::
* car-safe::
* cdr-safe::
* nconc::
@end menu

@FirstSubSubSecInstruction{nth, 56}

Call @code{nth} with two stack arguments. For a description of this
Emacs Lisp function,  @xref{List Elements, ,Accessing Elements of Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (nth S[1] TOS); top--}.
@item Generated via:
@code{nth}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: List; S[1]: Number}

@strong{after:} @code{TOS: Object}

Note the that the order of the stack values is opposite @code{nthcdr} even though
in Emacs Lisp the order of the parameters is the same for both functions.

@item Example:
When lexical binding is in effect, @code{(defun nth-eg(l) (nth 560 l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 560
 1    1   stack-ref[1]
 2   56   nth
 3  135   return

Constants Vector: [560]
@end verbatim

@end table

@SubSubSecInstruction{car, 64}

Call @code{car} with one stack argument. For a description of this
Emacs Lisp function, @xref{List Elements, ,Accessing Elements of Lists,
elisp, The GNU Emacs Lisp Reference Manual}.


@table @strong

@item Implements:
@code{TOS <- (car TOS)}.

@item Generated via:
@code{car}.

@item Instruction size:
1 byte

@item Stack effect:
@math{-1+1}.

@item Type Information:

@strong{before:} @code{TOS: Cons-cell}

@strong{after:} @code{TOS: Object}

@item Example:
When lexical binding is in effect, @code{(defun car-eg(l) (car l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   64   car
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{cdr, 65}

Call @code{cdr} with one stack argument. For a description of this
Emacs Lisp function, @xref{List Elements, ,Accessing Elements of Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (cdr TOS)}.
@item Generated via:
@code{cdr}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.

@item Type Information:

@strong{before:} @code{TOS: Cons-cell}

@strong{after:} @code{TOS: Object}


@item Example:
When lexical binding is in effect, @code{(defun cdr-eg(l) (cdr l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   65   cdr
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{cons, 66}

Call @code{cons} with two stack arguments. For a description of this
Emacs Lisp function, @xref{Building Lists, ,Building Cons Cells and Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (cons S[1] TOS); top--}.
@item Generated via:
@code{cons}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun cons-eg() (cons 'a 'b))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2   66   cons
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table


@SubSubSecInstruction{list1, 67}

Call @code{list} with TOS. For a description of this
Emacs Lisp function, @xref{Building Lists, ,Building Cons Cells and Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (list TOS)}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Type Information:

@strong{before:} @code{TOS: Object}

@strong{after:} @code{TOS: List}


@item Example:
@code{(defun list1-eg() (list 'a))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1   67   list1
 2  135   return

Constants Vector: [a]
@end verbatim

@end table

Call @code{list} with TOS.

@SubSubSecInstruction{list2, 68}

Call @code{list} with two stack items. For a description of this
Emacs Lisp function, @xref{Building Lists, ,Building Cons Cells and Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (list S[1] TOS); top--}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Type Information:

@strong{before:} @code{S[1]: Object; TOS: Object}

@strong{after:} @code{TOS: List}


@item Example:
@code{(defun list2-eg() (list 'a 'b))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2   68   list2
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{list3, 69}

Call @code{list} with three stack items. For a description of this
Emacs Lisp function, @xref{Building Lists, ,Building Cons Cells and Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[2] <- (list S[2] S[1] TOS); top -= 2}.
@item Generated via:
@code{list}
@item Instruction size:
1 byte
@item Stack effect:
@math{-3+1}.

@item Type Information:

@strong{before:} @code{S[2]: Object; S[1]: Object; TOS: Object}

@strong{after:} @code{TOS: List}

@item Example:
@code{(defun list3-eg() (list 'a 'b 'c))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3   69   list3
 4  135   return

Constants Vector: [a b c]
@end verbatim

@end table

@SubSubSecInstruction{list4, 70}

Call @code{list} with four stack items. For a description of this
Emacs Lisp function, @xref{Building Lists, ,Building Cons Cells and Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[3] <- (list S[3] S[2] S[1] TOS); top -= 2}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-4+1}.
@item Type Information:

@strong{before:} @code{S[3]: Object; S[2]: Object; S[1]: Object; TOS: Object}

@strong{after:} @code{TOS: List}

@item Example:
@code{(defun list4-eg() (list 'a 'b 'c 'd))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3  195   constant[3] d
 4   70   list4
 5  135   return

Constants Vector: [a b c d]
@end verbatim

@end table

@SubSubSecInstruction{listN, 175}

Call @code{list} on up to 255 items. For
a description of this Emacs Lisp function, @xref{Building Lists, ,Building
Cons Cells and Lists, elisp, The GNU Emacs Lisp Reference Manual}.

Note that there are special
instruction for the case where there are 1 to 4 items in the
list.

@table @strong
@item Implements:
@code{S[n-1] <- (list S[n-1] S[n-2] ... TOS); top -= (OPERAND-1)}
@item Generated via:
@code{list}.
@item Operand:
8-bit number of items in list
@item Instruction size:
2 bytes
@item Stack effect:
@math{-@code{OPERAND}+1}

@strong{before:} @code{S[OPERAND-1]: Object; ... S[1]: Object; TOS: Object}

@strong{after:} @code{TOS: List}


@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun listN-eg() (list 'a 'b 'c 'd 'e))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3  195   constant[3] d
 4  196   constant[4] e
 5  175   listN [5]
           5
 7  135   return

Constants Vector: [a b c d e]
@end verbatim

@end table


@SubSubSecInstruction{length, 71}

Call @code{length} with one stack argument. For a description of this
Emacs Lisp function, @xref{Sequence Functions, ,Sequences, elisp, The
GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (length TOS)}.
@item Generated via:
@code{length}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun length-eg() (length '(a b)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (a b)
 1   71   length
 2  135   return

Constants Vector: [(a b)]
@end verbatim

@end table

@SubSubSecInstruction{aref, 72}

Call @code{aref} with two stack arguments. For a description of this
Emacs Lisp function, @xref{Array Functions, ,Functions that Operate on
Arrays, elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (aref S[1] TOS); top--}.
@item Generated via:
@code{aref}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun aref-eg() (aref '[720 721 722] 0))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] [720 721 722]
 1  193   constant[1] 0
 2   72   aref
 3  135   return

Constants Vector: [[720 721 722] 0]
@end verbatim

@end table

@SubSubSecInstruction{aset, 73}

Call @code{aset} with three stack arguments. For a description of this
Emacs Lisp function, @xref{Array Functions, ,Functions that Operate on
Arrays, elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[2] <- (aset S[2] S[1] TOS); top-=2}.
@item Generated via:
@code{aset}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun aset-eg() (aset array-var 0 730))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0    8   varref[0] array-var
 1  193   constant[1] 0
 2  194   constant[2] 730
 3   73   aset
 4  135   return

Constants Vector: [array-var 0 730]
@end verbatim

@end table


@SubSubSecInstruction{nthcdr, 155}

Call @code{nthcdr} with two stack arguments. For a description of this
Emacs Lisp function,  @xref{List Elements, ,Accessing Elements of Lists,
elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (nthcdr S[1] TOS); top --}.
@item Generated via:
@code{nthcdr}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: List}

@strong{after:} @code{TOS: Object}

Note the that the order of the stack values is opposite @code{nth} even though
in Emacs Lisp the order of the parameters is the same for both functions.

@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun nthcdr-eg() (nthcdr '(1550 1551 1552) 2))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (1550 1551 1552)
 1  193   constant[1] 2
 2  155   nthcdr
 3  135   return

Constants Vector: [(1550 1551 1552) 2]
@end verbatim

@end table


@SubSubSecInstruction{elt, 156}

Call @code{elt} with two stack arguments. For a description of this
Emacs Lisp sequence function, @xref{Sequence Functions, ,Sequences, elisp, The
GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (elt S[1] TOS); top --}.
@item Generated via:
@code{elt}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun elt-eg() (elt '(1560 1561 1562) 2))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (1560 1561 1562)
 1  193   constant[1] 2
 2  156   elt
 3  135   return

Constants Vector: [(1560 1561 1562) 2]
@end verbatim

@end table

@SubSubSecInstruction{nreverse, 159}

Call @code{nreverse} with one stack argument. For a description of
this Emacs Lisp function, @xref{Sequence Functions, ,Sequences, elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (elt TOS)}.
@item Generated via:
@code{nreverse}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun nreverse-eg() (nreverse '(1590 1591)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (1590 1591)
 1  159   nreverse
 2  135   return

Constants Vector: [(1590 1591)]
@end verbatim

@end table

@SubSubSecInstruction{setcar, 160}

Call @code{setcar} with two stack arguments. For a description of this Emacs Lisp function, @xref{Setcar, ,Altering
List Elements with @code{setcar}, elisp, The GNU Emacs Lisp Reference
Manual}.

@table @strong
@item Implements:
@code{S[1] <- (setcar S[1] TOS); top--}.
@item Generated via:
@code{setcar}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: object; S[1]: cons}

@strong{after:} @code{TOS: Object}

@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun setcar-eg(l) (setcar l 1600)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  192   constant[0] 1600
 2  160   setcar
 3  135   return

Constants Vector: [1600]
@end verbatim

@end table

@SubSubSecInstruction{setcdr, 161}

Call @code{setcdr} with two stack arguments. For a description of this
Emacs Lisp function, @xref{Setcdr, ,Altering the CDR of a List, elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (setcdr S[1] TOS); top--}.
@item Generated via:
@code{setcdr}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Object; S[1]: Cons-cell}

@strong{after:} @code{TOS: Object}

@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun setcdr-eg(l) (setcdr l 1610)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  192   constant[0] 1610
 2  161   setcdr
 3  135   return

Constants Vector: [1610]
@end verbatim

@end table

@SubSubSecInstruction{car-safe, 162}

Call @code{car-safe} with one argument. For a description of this Emacs Lisp function, @xref{List Elements, ,
Accessing Elements of Lists, elisp, The GNU Emacs Lisp Reference
Manual}.

@table @strong
@item Implements:
@code{TOS <- (car-safe TOS)}.
@item Generated via:
@code{car-safe}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.

@item Type Information:

@strong{before:} @code{TOS: Cons-cell}

@strong{after:} @code{TOS: Object}

@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun car-safe-eg(l) (car-safe l))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  162   car-safe
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{cdr-safe, 163}

Call @code{cdr-safe} with one argument. For a description of this
Emacs Lisp function, @xref{List Elements, ,Accessing Elements of
Lists,elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (cdr-safe TOS)}.
@item Generated via:
@code{cdr-safe}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.

@item Type Information:

@strong{before:} @code{TOS: Cons-cell}

@strong{after:} @code{TOS: Object}

@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun cdr-safe-eg(l) (cdr-safe l))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  163   cdr-safe
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{nconc, 164}

Call @code{nconc} with two stack arguments. For a description of this
Emacs Lisp function, @xref{Setcdr, ,Altering the CDR of a List,elisp,
The GNU Emacs Lisp Reference Manual}.

The Emacs Lisp function @code{nconc} can take an arbitrary number of
arguments. The bytecode compiler breaks these up into repeated binary
operations.

@table @strong
@item Implements:
@code{S[1] <- (nconc S[1] TOS); top--}.
@item Generated via:
@code{nconc}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Type Information:

@strong{before:} @code{TOS: List; S[1]: List}

@strong{after:} @code{TOS: List}


@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun nconc-eg(l1 l2 l3) (nconc l1 l2 l3))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0    2   stack-ref[2]
 1    2   stack-ref[2]
 2  164   nconc
 3    1   stack-ref[1]
 4  164   nconc
 5  135   return
@end verbatim

@end table

@Subsection{Arithmetic Function Instructions}

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* sub1::
* add1::
* eqlsign::
* gtr::
* lss::
* leq::
* geq::
* diff::
* negate::
* plus::
* mult::
* max::
* min::
* quo::
* rem::
@end menu

@FirstSubSubSecInstruction{sub1, 83}

Call @code{1-}. For a description of this Emacs Lisp arithmetic operation, @xref{Arithmetic Operations, ,Arithmetic Operations,elisp, The GNU Emacs Lisp Reference
Manual}.

@table @strong
@item Implements:
@code{TOS <- (1- TOS)}.
@item Generated via:
@code{1-}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.

@item Type Information:

@strong{before:} @code{TOS: Number}

@strong{after:} @code{TOS: Number}


@item Example:
When lexical binding is in effect, @code{(defun sub1-eg(n) (1- n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   83   sub1
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{add1, 84}

Call @code{1+}. For a description of this Emacs Lisp arithmetic
operation, @xref{Arithmetic Operations, ,Arithmetic Operations,elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (1+ TOS)}.
@item Generated via:
unary @code{-}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.

@item Type Information:

@strong{before:} @code{TOS: Number}

@strong{after:} @code{TOS: Number}

@item Example:
When lexical binding is in effect, @code{(defun add1-eg(n) (1+ n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   84   add1
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{eqlsign, 85}

Call @code{=}. For a description of this Emacs Lisp comparision
function, @xref{Comparison of Numbers, ,Comparison of Numbers,elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (= S[1] TOS); top--}.
@item Generated via:
binary @code{=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}

@item Example:
When dynamic binding is in effect, @code{(defun eqlsign-eg(a b) (= a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   85   eqlsign
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{gtr, 86}

Call @code{>}. For a description of this Emacs Lisp function,
@xref{Comparison of Numbers, ,Comparison of Numbers,elisp, The GNU
Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (> S[1] TOS); top--}.
@item Generated via:
@code{>}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}

@item Example:
When lexical binding is in effect, @code{(defun gtr-eg(a b) (> a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   86   gtr
 3  135   return
@end verbatim

@end table

@SubSubSecInstruction{lss, 87}

Call @code{<}. For a description of this Emacs Lisp function, @xref{Comparison of Numbers, ,Comparison of Numbers,elisp, The GNU Emacs Lisp Reference
Manual}.

@table @strong
@item Implements:
@code{S[1] <- (< S[1] TOS); top--}.
@item Generated via:
@code{<}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}


@item Example:
When dynamic binding is in effect, @code{(defun lss-eg(a b) (< a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   87   lss
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{leq, 88}

Call @code{<=}. For a description of this Emacs Lisp function, @xref{Comparison of Numbers, ,Comparison of Numbers,elisp, The GNU Emacs Lisp Reference
Manual}.

@table @strong
@item Implements:
@code{S[1] <- (<= S[1] TOS); top--}.
@item Instruction size:
1 byte
@item Generated via:
@code{<=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}


@item Example:
When dynamic binding is in effect, @code{(defun leq-eg(a b) (<= a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   88   leq
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{geq, 89}

Call @code{>=}. For a description of this Emacs Lisp function,
@xref{Comparison of Numbers, ,Comparison of Numbers,elisp, The GNU
Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (>= S[1] TOS); top--}.
@item Instruction size:
1 byte
@item Generated via:
@code{>=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}


@item Example:
When lexical binding is in effect, @code{(defun geq-eg(a b) (>= a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   89   geq
 3  135   return
@end verbatim

@end table

@SubSubSecInstruction{diff, 90}

Call binary @code{-}. For a description of this Emacs Lisp function,
@xref{Arithmetic Operations, ,Arithmetic Operations,elisp, The GNU
Emacs Lisp Reference Manual}.

When the argument list is more than two, a @code{call} instruction is used instead.

@table @strong
@item Implements:
@code{S[1] <- (- S[1] TOS); top--}.
@item Generated via:
binary @code{-}.
@item Instruction size:
1 byte
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}

@item Example:
When lexical binding is in effect, @code{(defun diff-eg(a b) (- a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   90   diff
 3  135   return
@end verbatim

@end table

@SubSubSecInstruction{negate, 91}

Call unary @code{-}. For a description of this Emacs Lisp function, @xref{Arithmetic Operations, ,Arithmetic Operations,elisp, The GNU Emacs Lisp Reference
Manual}.

@table @strong
@item Implements:
@code{TOS <- (- TOS)}.
@item Generated via:
unary @code{-}.
@item Instruction size:
1 byte
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.

@item Type Information:

@strong{before:} @code{TOS: Number}

@strong{after:} @code{TOS: Number}

@item Example:
When lexical binding is in effect, @code{(defun negate-eg(a) (- a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1   91   negate
 2  135   return

Constants Vector: [a]
@end verbatim

@end table

@SubSubSecInstruction{plus, 92}

Call binary @code{+}. For a description of this Emacs Lisp arithmetic
operation, @xref{Arithmetic Operations, ,Arithmetic Operations,elisp,
The GNU Emacs Lisp Reference Manual}.

When adding more than two numbers, a @code{call} instruction is used instead.

@table @strong
@item Implements:
@code{S[1] <- (+ S[1] TOS); top--}.
@item Generated via:
@code{+}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}

@item Example:
When dynamic binding is in effect, @code{(defun plus-eg(n) (+ n n))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  137   dup
 2   92   plus
 3  135   return

Constants Vector: [n]
@end verbatim

@end table

@SubSubSecInstruction{mult, 95}

Call binary @code{*}. For a description of this Emacs Lisp arithmetic
operation, @xref{Arithmetic Operations, ,Arithmetic Operations,elisp,
The GNU Emacs Lisp Reference Manual}.

When multiplying more than two numbers, a @code{call} instruction is used instead.

@table @strong
@item Implements:
@code{S[1] <- (* S[1] TOS); top--}.
@item Generated via:
@code{*}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: String; S[1]: String}

@strong{after:} @code{TOS: Bool}


@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When dynamic binding is in effect, @code{(defun mult-eg(n) (* n n))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  137   dup
 2   95   mult
 3  135   return

Constants Vector: [n]
@end verbatim

@end table

@SubSubSecInstruction{max, 93}

Call binary @code{max}. For a description of this Emacs Lisp
comparision function, @xref{Comparison of Numbers, ,Comparison of
Numbers,elisp, The GNU Emacs Lisp Reference Manual}.

The Emacs Lisp function @code{max} can take an arbitrary number of
arguments. The bytecode compiler breaks these up into repeated binary
operations.

@table @strong
@item Implements:
@code{S[1] <- (max S[1] TOS); top--}.
@item Generated via:
@code{max}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}


@item Example:
When dynamic binding is in effect, @code{(defun max-eg(a b c) (max a b c))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   93   max
 3   10   varref[2] c
 4   93   max
 5  135   return

Constants Vector: [a b c]
@end verbatim

@end table

@SubSubSecInstruction{min, 94}

Call binary @code{min}. For a description of this Emacs Lisp
comparison function, @xref{Comparison of Numbers, ,Comparison of
Numbers,elisp, The GNU Emacs Lisp Reference Manual}.

The Emacs Lisp function @code{min} can take an arbitrary number of arguments. The
bytecode compiler breaks these up into repeated binary operations.

@table @strong
@item Implements:
@code{TOS <- (min(S[1] TOS)}.
@item Generated via:
binary @code{min}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}

@item Example:
When dynamic binding is in effect, @code{(defun min-eg(a b c) (min a b c))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   94   min
 3   10   varref[2] c
 4   94   min
 5  135   return

Constants Vector: [a b c]
@end verbatim

@end table

@SubSubSecInstruction{quo, 165}

Call @code{/}. For a description of this Emacs Lisp arithmetic
operator, @xref{Arithmetic Operations, ,Arithmetic Operations,elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (/ S[1] TOS); top--}.
@item Generated via:
@verb{|/|}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}

A zero value for @code{TOS} will raise an arithmetic error.

@item Example:
When dynamic binding is in effect, @code{(defun min-quo(a b) (/ a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2  165   quo
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@SubSubSecInstruction{rem, 166}

Call @verb{|%|}. For a description of this Emacs Lisp arithmetic
operator, @xref{Arithmetic Operations, ,Arithmetic Operations,elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item implements:
@code{S[1] <- (% S[1] TOS); top--}.
@item generated via:
@verb{|%|}
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}

@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}

A zero value for @code{TOS} will raise an arithmetic error.


@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect, @code{(defun rem-eg(a b) (% a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  166   rem
 3  135   return
@end verbatim

@end table

@Subsection{String Function Instructions}

These instructions correspond to general functions which are not
specific to Emacs; the bytecode interpreter calls the corresponding C
function for them.

@menu
* substring::
* concat2::
* concat3::
* concat4::
* concatN::
* upcase::
* downcase::
* stringeqlsign::
* stringlss::
@end menu

@FirstSubSubSecInstruction{substring, 79}

Call @code{substring} with three stack arguments. For a description of
this Emacs Lisp string function, @xref{Creating Strings, ,Creating
Strings,elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[2] <- (substring S[2] S[1] TOS); top-=2}.
@item Generated via:
@code{substring}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun substring-eg() (substring "abc" 0 2))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "abc"
 1  193   constant[1] 0
 2  194   constant[2] 2
 3   79   substring
 4  135   return

Constants Vector: ["abc" 0 2]
@end verbatim

@end table


@SubSubSecInstruction{concat2, 80}

Call @code{concat} with two stack arguments. For a description of this Emacs Lisp function string
function, @xref{Creating Strings, ,Creating Strings,elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (concat S[1] TOS); top--}.
@item Generated via:
@code{concat}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun concat2-eg() (concat "a" "b"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "a"
 1  193   constant[1] "b"
 2   80   concat2
 3  135   return

Constants Vector: ["a" "b"]
@end verbatim

@end table

@SubSubSecInstruction{concat3, 81}

Call @code{concat} with three stack arguments. For a description of this Emacs Lisp function string
function, @xref{Creating Strings, ,Creating Strings,elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[2] <- (concat S[2] S[1] TOS); top-=2}.
@item Generated via:
@code{concat}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun concat3-eg() (concat "a" "b" "c"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "a"
 1  193   constant[1] "b"
 2  194   constant[2] "c"
 3   81   concat3
 4  135   return

Constants Vector: ["a" "b" "c"]
@end verbatim

@end table


@SubSubSecInstruction{concat4, 82}

Call @code{concat} with four stack stack arguments. For a description of this Emacs Lisp function string
function, @xref{Creating Strings, ,Creating Strings,elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[3] <- (concat S[3] S[2] S[1] TOS); top -= 2}.
@item Generated via:
@code{concat}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-4+1}.
@item Example:
@code{(defun concat4-eg() (concat "a" "b" "c" "d"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "a"
 1  193   constant[1] "b"
 2  194   constant[2] "c"
 3  195   constant[3] "d"
 4   82   concat4
 5  135   return

Constants Vector: ["a" "b" "c" "d"]
@end verbatim

@end table


@SubSubSecInstruction{concatN, 174}

Call @code{concat} on up to 255 stack arguments.  Note there are
special instructions for the case where there are 2 to 4 items to
concatenate. For a description of this Emacs Lisp function string
function, q@xref{Creating Strings, ,Creating Strings,elisp, The GNU
Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[n-1] <- (concat S[n-1] S[n-2] ... TOS); top -= (n-1)}.
@item Generated via:
@code{concat}.
@item Operand:
8-bit number of items in concat
@item Instruction size:
2 bytes
@item Stack effect:
@math{-n+1} where @math{n} is the value of the instruction operand.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun concatN-eg() (concat "a" "b" "c" "d" "e"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "a"
 1  193   constant[1] "b"
 2  194   constant[2] "c"
 3  195   constant[3] "d"
 4  196   constant[4] "e"
 5  176   concatN [5]
           5
 7  135   return

Constants Vector: ["a" "b" "c" "d" "e"]
@end verbatim

@end table

@SubSubSecInstruction{upcase, 150}

Call @code{upcase} with one stack argument. For a description of this
Emacs Lisp string function, @xref{Case Conversion, ,Case Conversion in
Lisp,elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (upcase TOS)}.
@item Generated via:
@code{upcase}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun upcase-eg() (upcase "abc"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "abc"
 1  150   upcase
 2  135   return

Constants Vector: ["abc"]
@end verbatim

@end table

@SubSubSecInstruction{downcase, 151}

Call @code{downcase} with one argument. For a description of this
Emacs Lisp string function, @xref{Case Conversion, ,Case Conversion in
Lisp,elisp, The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (downcase TOS)}.
@item Generated via:
@code{downcase}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun downcase-eg(l) (downcase "ABC"))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "ABC"
 1  151   downcase
 2  135   return

Constants Vector: ["ABC"]
@end verbatim

@end table

@SubSubSecInstruction{stringeqlsign, 152}

Call @code{string=} with two stack arguments, comparing two strings
for equality. For a description of this Emacs Lisp string function,
@xref{Text Comparison, ,Comparison of Characters and Strings,elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (string= S[1] TOS); top--}.
@item Generated via:
@code{string=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Type Information:

@strong{before:} @code{TOS: Number; S[1]: Number}

@strong{after:} @code{TOS: Number}



@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect,
@verbatim
(defun stringeqlsign-eg(a)
  (string= a "b"))
@end verbatim
generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  192   constant[0] "b"
 2  152   string=
 3  135   return

Constants Vector: ["b"]
@end verbatim

@end table

@SubSubSecInstruction{stringlss, 153}

Call @code{string<} with two stack arguments, comparing two
strings. For a description of this Emacs Lisp string function,
@xref{Text Comparison, ,Comparison of Characters and Strings,elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{S[1] <- (string< S[1] TOS); top--}.
@item Generated via:
@code{string<}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Type Information:

@strong{before:} @code{TOS: String; S[1]: String}

@strong{after:} @code{TOS: Bool}


@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect,
@verbatim
(defun stringlss-eg(a)
  (string< a "b"))
@end verbatim
generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  192   constant[0] "b"
 2  153   string<
 3  135   return

Constants Vector: ["b"]
@end verbatim

@end table

@Subsection{Emacs Buffer Instructions}

@menu
* current-buffer::
* set-buffer::
* save-current-buffer-1::
* buffer-substring::
@end menu

@FirstSubSubSecInstruction{current-buffer, 112}

Call @code{current-buffer}. For a description of this Emacs Lisp buffer function,
@xref{Current Buffer, ,The Current Buffer,elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (current-buffer)}

@item Generated via:
@code{current-buffer}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun current-buffer-eg() (current-buffer))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  112   current-buffer
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{set-buffer, 113}

Call @code{set-buffer} with TOS. For a description of this Emacs Lisp buffer function,
@xref{Current Buffer, ,The Current Buffer,elisp,
The GNU Emacs Lisp Reference Manual}.

@table @strong
@item Implements:
@code{TOS <- (set-buffer TOS)}

@item Generated via:
@code{set-buffer}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun set-buffer-eg() (set-buffer "*scratch"))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "*scratch"
 1  113   set-buffer
 2  135   return

Constants Vector: ["*scratch"]
@end verbatim

@end table

@SubSubSecInstruction{save-current-buffer-1, 114}

Call @code{save-current-buffer}. For a description of this Emacs Lisp buffer function,
@xref{Current Buffer, ,The Current Buffer,elisp,
The GNU Emacs Lisp Reference Manual}.

Replaces older @code{save-current-buffer}. @xref{save-current-buffer}.

@table @strong
@item Implements:
@code{to be filled in...}

@item Generated via:
@code{save-current-buffer}
@item Instruction size:
1 byte
@item Stack effect:
@math{0+1}?
@item Added in:
Emacs 22. @xref{Emacs 22}.
@item Example:
@verbatim
(defun save-current-buffer-1-eg()
   (save-current-buffer (prog 5)))}
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  114   save-current-buffer
 1  192   constant[0] prog
 2  193   constant[1] 5
 3   33   call[1]
 4   41   unbind[1]
 5  135   return

Constants Vector: [prog 5]
@end verbatim

@end table

@SubSubSecInstruction{buffer-substring, 123}

Call @code{buffer-substring} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (buffer-substring S[1] TOS); top--}. For a description of this Emacs Lisp buffer function,
@xref{Buffer Contents, ,Examining Buffer Contents,elisp,
The GNU Emacs Lisp Reference Manual}.
@item Generated via:
@code{buffer-substring}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun buffer-substring-eg() (buffer-substring 1230 1231))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1230
 1  193   constant[1] 1231
 2  123   buffer-substring
 3  135   return

Constants Vector: [1230 1231]
@end verbatim

@end table

@Subsection{Emacs Position Instructions}

These instructions correspond to Emacs-specific position functions
that are found in the "Positions" chapter of the Emacs Lisp Reference
Manual. They are not inlined by the bytecode interpreter, but simply
call the corresponding C function.

@menu
* point::
* goto-char::
* point-max::
* point-min::
* forward-char::
* forward-word::
* forward-line::
* skip-chars-forward::
* skip-chars-backward::
* narrow-to-region::
* widen::
@end menu


@FirstSubSubSecInstruction{point, 96}

Call @code{point}.

@table @strong
@item Implements:
@code{TOS <- (point)}

@item Generated via:
@code{point}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 18.31, renamed from @code{dot}. @xref{Emacs 18}.
@item Example:
@code{(defun point-eg() (point))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0   96   point
 1  135   return
@end verbatim

@end table


@SubSubSecInstruction{goto-char, 98}

Call @code{goto-char} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (goto-char TOS)}

@item Generated via:
@code{goto-char}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
With lexical binding in effect, @code{(defun goto-char-eg(n) (goto-char n))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   98   goto-char
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{point-max, 100}

Call @code{point-max}.

@table @strong
@item Implements:
@code{TOS <- (point-max)}

@item Generated via:
@code{point-max}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 18.31, renamed from @code{dot-max}. @xref{Emacs 18}.
@item Example:
@code{(defun point-max-eg() (point-max))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  100   point-max
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{point-min, 101}

Call @code{point-min}.

@table @strong
@item Implements:
@code{TOS <- (point-min)}

@item Generated via:
@code{point-min}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 18.31, renamed from @code{dot-min}. @xref{Emacs 18}.
@item Example:
@code{(defun point-min-eg() (point-min))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  101   point-min
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{forward-char, 117}

Call @code{forward-char} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (forward-char TOS)}

@item Generated via:
@code{forward-char}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun forward-char-eg() (forward-char 1))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1
 1  117   forward-char
 2  135   return

Constants Vector: [1]
@end verbatim

@end table

@SubSubSecInstruction{forward-word, 118}

Call @code{forward-word} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (forward-word TOS)}

@item Generated via:
@code{forward-word}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun forward-word-eg() (forward-word 1))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1
 1  118   forward-word
 2  135   return

Constants Vector: [1]
@end verbatim

@end table

@SubSubSecInstruction{forward-line, 121}

Call @code{forward-line} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (forward-line TOS)}

@item Generated via:
@code{forward-line}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun forward-line-eg() (forward-line 1))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1
 1  121   forward-line
 2  135   return

Constants Vector: [1]
@end verbatim

@end table

@SubSubSecInstruction{skip-chars-forward, 119}

@kindex skip-chars-forward
Call @code{skip-chars-forward} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (skip-chars-forward S[1] TOS); top--}.
@item Generated via:
@code{skip-chars-forward}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun skip-chars-forward-eg() (skip-chars-forward "aeiou" 3))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "aeiou"
 1  193   constant[1] 3
 2  119   skip-chars-forward
 3  135   return

Constants Vector: ["aeiou" 3]
@end verbatim

@end table

@SubSubSecInstruction{skip-chars-backward, 120}

Call @code{skip-chars-backward} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (skip-chars-backward S[1] TOS); top--}.
@item Generated via:
@code{skip-chars-backward}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun skip-chars-backward-eg() (skip-chars-backward "aeiou" 3))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "aeiou"
 1  193   constant[1] 3
 2  120   skip-chars-backward
 3  135   return

Constants Vector: ["aeiou" 3]
@end verbatim

@end table

@SubSubSecInstruction{narrow-to-region, 125}

Call @code{narrow-to-region} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (narrow-to-region S[1] TOS); top--}.
@item Generated via:
@code{narrow-to-region}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun narrow-to-region-eg() (narrow-to-region 1250 1251))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1250
 1  193   constant[1] 1251
 2  125   narrow-to-region
 3  135   return

Constants Vector: [1250 1251]
@end verbatim

@end table

@SubSubSecInstruction{widen, 126}

Call @code{widen}.

@table @strong
@item Implements:
@code{TOS <- (widen)}

@item Generated via:
@code{widen}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun widen-eg() (widen))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  126   widen
 1  135   return
@end verbatim

@end table

@Subsection{Emacs Text Instructions}

These instructions correspond to Emacs-specific text manipulation
functions found in the "Text" chapter of the Emacs Lisp Reference
Manual. They are not inlined by the bytecode interpreter, but simply
call the corresponding C function.

@menu
* insert::
* insertN::
* char-after::
* following-char::
* preceding-char::
* current-column::
* indent-to::
* eolp::
* eobp::
* bolp::
* bobp::
* delete-region::
* end-of-line::
@end menu

@FirstSubSubSecInstruction{insert, 99}

Call @code{insert} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (insert TOS)}

@item Generated via:
@code{insert}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
With lexical binding in effect, @code{(defun insert-eg(n) (insert n))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   99   insert
 2  135   return
@end verbatim

@end table

@SubSubSecInstruction{insertN, 99}

Call @code{insert} on up to 255 stack arguments.  Note there is a special
instruction when there is only one stack argument.

@table @strong
@item Implements:
@code{S[n-1] <- (insert S[n-1] S[n-2] ... TOS); top -= (n-1)}.

@item Generated via:
@code{insert}
@item Operand:
8-bit number of items in concat
@item Instruction size:
2 bytes
@item Stack effect:
@math{-n+1} where @math{n} is the value of the instruction operand.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
With lexical binding in effect, @code{(defun insertN-eg(a b c) (insert a b c))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0    2   stack-ref[2]
 1    2   stack-ref[2]
 2    2   stack-ref[2]
 3  177   insertN [3]
           3
 5  135   return
@end verbatim

@end table

@SubSubSecInstruction{char-after, 102}

Call @code{char-after} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (char-after TOS)}

@item Generated via:
@code{char-after}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun char-after-eg() (char-after))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] nil
 1  102   char-after
 2  135   return

Constants Vector: [nil]
@end verbatim

@end table

@SubSubSecInstruction{following-char, 103}

Call @code{following-char}.

@table @strong
@item Implements:
@code{TOS <- (following-char TOS)}

@item Generated via:
@code{following-char}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun following-char-eg() (following-char))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  103   following-char
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{preceding-char, 104}

Call @code{preceding-char}.

@table @strong
@item Implements:
@code{TOS <- (preceding-char TOS)}

@item Generated via:
@code{preceding-char}
@item Instruction size:
1 byte
@item Stack effect:
@math{0+1}.
@item Example:
@code{(defun preceding-char-eg() (preceding-char))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  104   preceding-char
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{current-column, 105}

Call @code{current-column}.

@table @strong
@item Implements:
@code{TOS <- (current-column)}

@item Generated via:
@code{current-column}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun current-column-eg() (current-column))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  105   current-column
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{indent-to, 106}

Call @code{indent-to}.

@table @strong
@item Implements:
@code{TOS <- (indent-to TOS)}

@item Generated via:
@code{indent-to}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun indent-to-eg() (indent-to 5))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 5
 1  106   indent-to
 2  135   return

Constants Vector: [5]
@end verbatim

@end table

@SubSubSecInstruction{eolp, 108}

Call @code{eolp}.

@table @strong
@item Implements:
@code{TOS <- (eolp)}

@item Generated via:
@code{eolp}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun eolp-eg() (eolp))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  108   eolp
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{eobp, 109}

Call @code{eobp}.

@table @strong
@item Implements:
@code{TOS <- (eobp)}

@item Generated via:
@code{eobp}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun eobp-eg() (eobp))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  109   eobp
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{bolp, 110}

Call @code{bolp}.

@table @strong
@item Implements:
@code{TOS <- (bolp)}

@item Generated via:
@code{bolp}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun bolp-eg() (bolp))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  110   bolp
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{bobp, 111}

Call @code{bobp}.

@table @strong
@item Implements:
@code{TOS <- (bobp)}

@item Generated via:
@code{bobp}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
@code{(defun bobp-eg() (bobp))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  111   bobp
 1  135   return
@end verbatim

@end table

@SubSubSecInstruction{delete-region, 124}

Call @code{delete-region} with two stack arguments.

Call @code{delete-region} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (delete-region S[1] TOS); top--}.
@item Generated via:
@code{delete-region}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun delete-region-eg() (delete-region 1240 1241))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1240
 1  193   constant[1] 1241
 2  124   delete-region
 3  135   return

Constants Vector: [1240 1241]
@end verbatim

@end table

@SubSubSecInstruction{end-of-line, 127}

Call @code{end-of-line} with one stack argument.

@table @strong
@item Implements:
@code{(end-of-line TOS; top--}
@item Generated via:
@code{delete-region}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+0-}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun end-of-line-eg() (end-of-line))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] nil
 1  127   end-of-line
 2  135   return

Constants Vector: [nil]
@end verbatim

@end table

@Subsection{Emacs Misc Function Instructions}

These instructions correspond to miscellaneous Emacs-specific
functions. They are not inlined by the bytecode interpreter, but
simply call the corresponding C function.

@menu
* char-syntax::
* unwind-protect::
* save-excursion::
* set-marker::
* match-beginning::
* match-end::
@end menu

@FirstSubSubSecInstruction{char-syntax, 122}

Call @code{char-syntax} with one stack argument.
@table @strong
@item Implements:
@code{TOS <- (char-syntax TOS)}

@item Generated via:
@code{char-syntax}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun char-syntax-eg() (char-syntax ?a))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 97
 1  122   char-syntax
 2  135   return

Constants Vector: [97]
@end verbatim

@end table

@SubSubSecInstruction{unwind-protect, 142}

To be completed...

@table @strong
@item Implements:
@code{(unwind-protect)}.
@item Generated via:
@code{unwind-protect}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+0}.
@item Example:
When lexical binding is in effect,
@code{(defun unwind-protect-eg() (unwind-protect (toggle-read-only)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] #[0 "\300\207" [nil] 1]
 1  142   unwind-protect
 2  193   constant[1] toggle-read-only
 3   32   call[0]
 4   41   unbind[1]
 5  135   return

Constants Vector: [#[0 "\300\207" [nil] 1] toggle-read-only]
@end verbatim

In the above, @code{constant[0]} is a nilary function that returns @code{nil}.
The disassembly of @code{\300\207} is:
@verbatim
PC  Byte  Instruction
 0  constant  nil
 1  return
@end verbatim
which is used when no unwind form was given.
@end table


@SubSubSecInstruction{save-excursion, 138}

Make a binding recording buffer, point, and mark.

This instruction manipulates the special-bindings stack by creating a
new binding when executed.  It needs to be balanced with
@code{unbind} instructions.

@table @strong
@item Implements:
@code{(save-excursion)}.
@item Generated via:
@code{save-excursion}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+0}.
@item Example:
When lexical binding is in effect,
@code{(defun save-excursion-eg() (save-excursion 1380))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  138   save-excursion
 1  192   constant[0] 1380
 2   41   unbind[1]
 3  135   return

Constants Vector: [1380]
@end verbatim

@end table


@SubSubSecInstruction{set-marker, 147}

Call @code{set-marker} with three stack arguments.

@table @strong
@item Implements:
@code{S[2] <- (set-marker S[2] S[1] TOS); top -= 2}.

@item Generated via:
@code{set-marker}
@item Instruction size:
1 byte
@item Stack effect:
@math{-3+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
When lexical binding is in effect,
@code{(defun set-marker-eg(marker position) (set-marker marker position))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  192   constant[0] nil
 3  147   set-marker
 4  135   return

Constants Vector: [nil]
@end verbatim

@end table

@SubSubSecInstruction{match-beginning, 148}

Call @code{match-beginning} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (match-beginning TOS)}

@item Generated via:
@code{match-beginning}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun match-beginning-eg() (match-beginning 1))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1
 1  148   match-beginning
 2  135   return

Constants Vector: [1]
@end verbatim

@end table

@SubSubSecInstruction{match-end, 149}

Call @code{match-end} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (match-end TOS)}

@item Generated via:
@code{match-end}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34. @xref{Emacs 19}.
@item Example:
@code{(defun match-end-eg() (match-end 1))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1
 1  148   match-end
 2  135   return

Constants Vector: [1]
@end verbatim

@end table

@SECTION{Stack-Manipulation Instructions}

@menu
* discard::
* discardN::
* dup::
* stack-set::
* stack-set2::
@end menu

@FirstSubSecInstruction{discard, 136}

Discard one value from the stack.

@kindex discard
@table @strong
@item Implements:
@code{top--}
@item Instruction size:
1 byte
@item Generated via:
Function calls that do not use the returned value; the end of @code{let} forms
in lexical binding to remove locally-bound variables.
@item Stack effect:
@math{-1+0}.
@item Example:
@code{(defun discard-eg() (exchange-point-and-mark) (point))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] exchange-point-and-mark
 1   32   call[0]
 2  136   discard
 3   96   point
 4  135   return

Constants Vector: [exchange-point-and-mark]
@end verbatim

@end table

@SubSecInstruction{discardN, 180}

Discards up to 127 arguments from the stack.  Note there is a special
instruction when there is only one argument.

@kindex discardN
@table @strong
@item Implements:
@code{if (n & 8) S[n] <- TOS; top -= n & 7;  } where @code{n} where @code{n}
is the value of the operand.
@item operand:
7-bit number of items to discard. The top 8th bit when set indicates to keep
the old TOS value after discarding.
@item Instruction size:
2 bytes
@item Generated via:
Function calls that do not use the returned value; the end of @code{let} forms
in lexical binding with optimization to remove locally-bound variables.
@item Stack effect:
@math{-n+0}
@item Added in:
Emacs 24.1. @xref{Emacs 24}.
@item Example:
When lexical binding is in effect and optimization are in effect,
@verbatim{(defun discardN-eg()
  (1+ (let ((a 1) (_b) (_c)) a)))
@end verbatim
generates:
@c ((lexical . t) (optimize . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1
 1  193   constant[1] nil
 2  137   dup
 3    2   stack-ref[2]
 4  182   discardN [131]
         131
 6   84   add1
 7  135   return

Constants Vector: [1 nil]
@end verbatim

@end table

@SubSecInstruction{dup, 137}

Make a copy of the top-of-stack value and push that onto the top of the evaluation stack.

@table @strong
@item Implements:
@code{top++; TOS <- S[1]}

@item Generated via:
@code{setq} in dynamic bindings to set a value and then use it. In lexical binding, to use the
first argument parameter.
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Example:
When lexical binding is in effect,
@verbatim{(defun dup-eg(n) n)
@end verbatim
generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup  ;; duplicates top of stack, argument n
 1  135   return
@end verbatim

@end table

@SubSecInstruction{stack-set, 178}

Sets a value on the evaluation stack to TOS.

@table @strong
@item Implements:
@code{S[i] <- TOS; top--} where @code{i} is the value of the
instruction operand.

Note that @code{stack-set[0]} has the same effect as @code{discard},
but does a little more work to do this.  @code{stack-set[1]} has the same
effect as @code{discardN 1} with the top bit of @code{discardN} set to
preserve @code{TOS}.

@item Generated via:
@code{let}, @code{let*} and lambda arguments.
@item Operand:
A 8-bit integer stack index
@item Instruction size:
2 bytes
@item Stack effect:
@math{-1+0}.
@item Added in:
Emacs 24.1. @xref{Emacs 24}.
@item Example:
When lexical binding is in effect and optimization
@verbatim
defun stack-set-eg()
(let ((a 5) a)))
@end verbatim
generates:
@c ((lexical . t) (optimize . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 5
 1  193   constant[1] nil
 2  193   constant[1] nil
 3  178   stack-set [2]
           2
 5  136   discard
 6  135   return

Constants Vector: [5 nil]
@end verbatim

@end table

@SubSecInstruction{stack-set2, 179}

@table @strong
@item Implements:
@code{S[i] <- TOS; top--} where @code{i} is the value of the
instruction operand.

Note that @code{stack-set2[0]} has the same effect as @code{discard},
but does a little more work to do this.  @code{stack-set2[1]} has the same
effect as @code{discardN 1} with the top bit of @code{discardN} set to
preserve @code{TOS}.

@item Generated via:
@code{let}, @code{let*} and lambda arguments.
@item Operand:
A 16-bit integer stack index
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}.
@item Added in:
Emacs 24.1. @xref{Emacs 24}.
@item Example:
??
@end table

@SECTION{Obsolete or Unused Instructions}

These instructions are not generated by Emacs Lisp bytecode
generation. In some cases, they were generated in a older version of
Emacs. In some cases the instructions may have been planned to being used but
never were. In some cases, the instructions are still handled if they
appear (such as from older bytecode), but in other cases they are no
longer accepted by the interpreter.

It is also possible that code outside of the Emacs Lisp distribution
generates these instructions.

@menu
* save-current-buffer::
* mark::
* scan-buffer::
* read-char::
* set-mark::
* interactive-p::
* save-window-excursion::
* condition-case::
* temp-output-buffer-setup::
* temp-output-buffer-show::
* unbind-all::
* Relative Goto Instructions::
@end menu

@FirstSubSecInstruction{save-current-buffer, 97}

Replaced by @code{save-current-buffer-1}. @xref{save-current-buffer-1}.

@FirstSubSecInstruction{mark, 97}

Used in V 17; obsolete in Emacs 18.31. @xref{Emacs 18}.

@FirstSubSecInstruction{scan-buffer, 107}

Obsolete in Emacs 18.31. @xref{Emacs 18}.

@FirstSubSecInstruction{read-char, 114}

@FirstSubSecInstruction{set-mark, 115}

Obsolete in Emacs 18.31. @xref{Emacs 18}.

@FirstSubSecInstruction{interactive-p, 116}

@FirstSubSecInstruction{save-window-excursion, 139}

Call @code{save-window-excursion}.

@table @strong
@item Implements:
@code{(save-window-excursion BLOCK)}

@item Generated via:
@code{save-window-excursion}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+0}.
@item Obsolete since:
Emacs 24.1. @xref{Emacs 24}. Now generates a sequence of bytecode that
includes calls to @code{current-window-configuration} and
@code{set-window-configuration}
@item Example:
@verbatim
(defun save-window-excursion()
   (save-window-excursion 1390))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (1390)
 1  139   save-window-excursion
 2  135   return

Constants Vector: [(1390)]
@end verbatim
@end table

@FirstSubSecInstruction{condition-case, 143}

Replaced by @code{pushconditioncase}. @xref{pushconditioncase}

@table @strong
@item Implements:
?
@item Generated via:
?
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Obsolete since:
Emacs 24.4. @xref{Emacs 24}.
@item Example:
@code{(defun condition-case-eg() (?))} generates:
@c ((lexical . t))
@verbatim
@end verbatim

@end table

@FirstSubSecInstruction{temp-output-buffer-setup, 144}

@table @strong
@item Implements:
Setup for @code{with-output-to-temp-buffer}.
@item Generated via:
@code{with-output-to-temp-buffer}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+0}.
@item Obsolete since:
Emacs 24.1. @xref{Emacs 24}.
@item Example:
@code{(defun wottb-eg () (with-output-to-temp-buffer "wottb" 5))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "wottb"
 1  144   temp-output-buffer-setup
 2  193   constant[1] 5
 3  145   temp-output-buffer-show
 4  135   return

Constants Vector: ["wottb" 5]
@end verbatim

@end table

@FirstSubSecInstruction{temp-output-buffer-show, 145}

@table @strong
@item Implements:
Finishing code of @code{with-output-to-temp-buffer}.
@item Generated via:
@code{with-output-to-temp-buffer}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+0}.
@item Obsolete in:
Emacs 24.1. @xref{Emacs 24}.
@item Example:
@code{(defun wottb-eg () (with-output-to-temp-buffer "wottb" 5))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "wottb"
 1  144   temp-output-buffer-setup
 2  193   constant[1] 5
 3  145   temp-output-buffer-show
 4  135   return

Constants Vector: ["wottb" 5]
@end verbatim
@end table

@FirstSubSecInstruction{unbind-all, 146}

Introduced in Emacs 19.34 for tail-recursion elimination by jwz, but
never used. @xref{Emacs 19}.

@Subsection{Relative Goto Instructions}

In Emacs 19.34, Hallvard Furuseth introduced relative goto
instructions.  However, they have rarely have been generated in
bytecode, and currently are not.

From Hallvard:
@quotation
Relative jump instructions: There's an apparently unanswered mail in
my mailbox about them being buggy and asking how they worked.
I expect they got disabled for that reason rather than someone trying
to debug.  I don't remember why I introduced them.  Maybe just a space
optimization and not worth the effort.  I hadn't quite learned that
there are times to not bother optimizing:-)
@end quotation

There have been reports however that others have used these instructions
in alternate languages that generate bytecode.

@menu
* Rgoto::
* Rgotoifnil::
* Rgotoifnonnil::
* Rgotoifnilelsepop::
* Rgotoifnonnilelsepop::
@end menu

@FirstSubSubSecInstruction{Rgoto, 170}

Relative jump version of @pxref{goto}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSubSecInstruction{Rgotoifnil, 171}

Relative jump version of @pxref{goto-if-nil}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSubSecInstruction{Rgotoifnonnil, 172}

Relative-jump version of @pxref{goto-if-not-nil}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSubSecInstruction{Rgotoifnilelsepop, 173}

Relative-jump version of @pxref{goto-if-nil-else-pop}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.

@FirstSubSubSecInstruction{Rgotoifnonnilelsepop, 174}

Relative-jump version of @pxref{goto-if-not-nil-else-pop}.

Introduced but unused in Emacs 19.34. @xref{Emacs 19}.
